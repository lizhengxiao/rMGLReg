---
title: "MGL-fitting"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MGL-fitting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
  library(rMGLReg)
  library(fitdistrplus)
  library(splines)
  library(snpar)
  data("danishmulti")
  dt <- data.table::data.table(danishmulti)
  dtnew <- dt[Building>0&Contents>0]
  y1 <- dtnew$Building
  y2 <- dtnew$Contents
  y <- cbind(y1, y2)
  
  # empirical cdf
  u1 <- snpar::kde(y[,1], kernel = "gaus", 
             xgrid = y[,1],
             h = 0.2)$Fhat
  u2 <- snpar::kde(y[,2], kernel = "gaus", 
             xgrid = y[,2],
             h = 0.2)$Fhat
  U <- cbind(u1, u2) # two-dim 
```



```{r, eval = FALSE}
m.norm <- MGL.mle(U = U,
                        copula  = "Normal",
                        initpar = 0.5)

m.t <- MGL.mle(U = U,
                     copula  = "t",
                     initpar = c(0.5, 4))
m.gumbel <- MGL.mle(U = U,
                     copula  = "Gumbel",
                          initpar = c(2))
m.MGLMGA180 <- MGL.mle(U,
                    copula  = "MGL180",
                             initpar = c(1))
m.MGB2 <- MGL.mle(U,
                      copula  = "MGB2",
                        initpar = c(0.1, 2, 0.4))

m.MGLEV180 <- MGL.mle(U,
                         copula  = "MGL-EV180",
                         initpar = c(2))


```



```{r, eval = FALSE}
recap <- function(x){
  res <- c(alpha = x$estimates,
           se = x$se,
           loglike = x$loglike,
           AIC = x$AIC, BIC = x$BIC)
  if(length(res) < 6)
    res <- c(res[1], NA, NA,res[2], NA, NA, res[3:5])
  if (length(res) > 6 & length(res) < 9)
    res <- c(res[1:2], NA, res[3:4], NA, res[5:7])
  res <- as.matrix(res)
  colnames(res) <- x$copula$name
  res}
res.all <- round(cbind(recap(m.norm),
                       recap(m.t),
                       recap(m.gumbel),
                       recap(m.MGLMGA180),
                       recap(m.MGB2),
                       recap(m.MGLEV180)
), 4)
out.com <- t(res.all)
out.com <- out.com[order(out.com[,9], decreasing = T),]
knitr::kable(out.com, digits = 3)

```


```{r, eval = FALSE}
library(copula)
ec <- empCopula(U) # the empirical copula

error.copula <- function(copula = c(
                      "MGL", "MGL180", "MGL-EV",
                      "MGL-EV180",
                      "Gumbel",
                      "Normal", "MGB2", "t"
                    ),
                         lowerLimit,
                         upperLimit,
                         pars ... ){
  
pnormcop <- function(U, param)
  as.numeric(pellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
ptcop <- function(U, param)
  as.numeric(pellipticalCopula(U, rho = param[1], type = "t",
                               param = param[2]))  # t copula
pgumcop <- function(U, param)
  as.numeric(pevCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme Value Copulae - gumbel copula
pMGLcop <- function(U, param){
  as.numeric(pcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}

pMGL180cop <- function(U, param){
  as.numeric(U[,1] + U[,2] - 1 + pcMGL.bivar(u1 = 1 - U[,1], u2 = 1 - U[,2], pars = param[1]))
}

pMGB2cop <- function(U, param){
  as.numeric(pcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}

pMGLEVcop <- function(U, param){
  as.numeric(pcMGLEV.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme Value Copulae - gumbel copula
}

pMGLEV180cop <- function(U, param){
  as.numeric(pcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme Value Copulae - gumbel copula
}
  
if (copula == "MGL") {
    pcop <- pMGLcop
  } else if (copula == "MGL180") {
    pcop <- pMGL180cop
  } else if (copula == "MGL-EV") {
    pcop <- pMGLEVcop
  } else if (copula == "MGL-EV180") {
    pcop <- pMGLEV180cop
  } else if (copula == "Gumbel") {
    pcop <- pgumcop
  } else if (copula == "Normal") {
    pcop <- pnormcop
  } else if (copula == "t") {
    pcop <- ptcop
  } else if (copula == "MGB2") {
    pcop <- pMGB2cop
  }
  
  error_c <- function()

  error <- cuhre(f = error_c,
                  lowerLimit = c(0.95, 0.95),
                  upperLimit = c(1, 1))$integral
  
                         }


```


