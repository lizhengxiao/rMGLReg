}
hcMGL.reg <- function(U, param) {
hfunc1 <- hcMGL.bivar(u1 = U[1], u2 = U[2], pars = param[1])$hfunc1
hfunc2 <- hcMGL.bivar(u1 = U[1], u2 = U[2], pars = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hcMGL180.reg <- function(U, param) {
hfunc1 <- 1 - hcMGL.bivar(u1 = 1 - U[1], u2 = 1 - U[2], pars = param[1])$hfunc1
hfunc2 <- 1 - hcMGL.bivar(u1 = 1 - U[1], u2 = 1 - U[2], pars = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hcMGLEV180.reg <- function(U, param) {
hfunc1 <- hcMGLEV180.bivar(u1 = U[1], u2 = U[2], param = param[1])$hfunc1
hfunc2 <- hcMGLEV180.bivar(u1 = U[1], u2 = U[2], param = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hcMGLEV.reg <- function(U, param) {
hfunc1 <- 1 - hcMGLEV180.bivar(u1 = 1 - U[1], u2 = 1 - U[2], param = param[1])$hfunc1
hfunc2 <- 1 - hcMGLEV180.bivar(u1 = 1 - U[1], u2 = 1 - U[2], param = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hgumcop.reg <- function(U, param) {
VineCopula::BiCopHfunc(u1 = U[1], u2 = U[2], family = 4, par = param[1])
}
if (copula == "MGL") {
dcop <- dcMGL.reg
hcop <- hcMGL.reg
} else if (copula == "MGL180") {
dcop <- dcMGL180.reg
hcop <- hcMGL180.reg
} else if (copula == "MGL-EV") {
dcop <- dcMGLEV.reg
hcop <- hcMGLEV.reg
} else if (copula == "MGL-EV180") {
dcop <- dcMGLEV180.reg
hcop <- hcMGLEV180.reg
} else if (copula == "Gumbel") {
dcop <- dgumcop.reg
hcop <- hgumcop.reg
}
# Obs1 <- obs[, 1] # y1 - the first vector of observations
Obs2 <- obs[, 2] # y2 - the second vector of observations
f1 <- f[, 1]
f2 <- f[, 2]
copLogL <- function(pars, X) {
ll <- 0
if (copula == "Gumbel") {
delta <- exp(X %*% pars) + 1
} else {
delta <- exp(X %*% pars)
}
for (i in seq_len(nrow(X))) {
if (Obs2[i] <= umin) {
ll[i] <- f1[i] * (hcop(U[i, ], param = delta[i])$hfunc1 - hcop(U_[i, ], param = delta[i])$hfunc1)
} else {
ll[i] <- f1[i] * f2[i] * dcop(U[i, ], param = delta[i])
}
}
res <- sum((log(ll)))
return(res)
}
resopt <- optim(
par = initpar,
fn = copLogL,
X = X,
hessian = hessian, ...
)
resopt
list(
loglike = -resopt$value,
copula = list(name = copula),
estimates = resopt$par,
se = sqrt(diag(solve(resopt$hessian))),
hessian = -resopt$hessian,
AIC = 2 * length(resopt$par) + 2 * resopt$value,
BIC = log(nrow(U)) * length(resopt$par) + 2 * resopt$value
)
}
m.MGLMGA180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
initpar = c(-0.32, 0.001, 0.001, 0.001))
m.MGLMGA180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.MGLMGA180
#' Fitting bivariate mixed MGL and MGL-EV copula regression models
#'
#' @description \code{MGL.reg.mixed} is used to fit bivariate MGL and MGL-EV copula regression models for continuous and semi-continuous variables.
#' @param obs two-dimenstional matrix for observations
#' @param U two-dimenstional matrix for pseudo copula data with values in \eqn{[0,1]} for (F(y1), F(y2)).
#' @param U_ two-dimenstional matrix for pseudo copula data for the data (F(y1), F(y2-1)).
#' @param X design matrix.
#' @param copula 'MGL', 'MGL180', "MGL-EV", "MGL-EV180"
#' @param umin Threshold
#' @param f values of the density function for marginal distribution.
#' @param initpar Initial values for the parameters to be optimized over.
#' @param hessian Logical. Should a numerically differentiated Hessian matrix be returned?
#' @param ... additional arguments, see \code{\link[stats]{optim}} for more details.
#' @importFrom stats qbeta
#' @importFrom stats optim
#' @return A list containing the following components:
#' * loglike: the value of the estimated maximum of the loglikelihood function.
#' * copula: the name of the fitted copula. "MGL180" and "MGL-EV180" denote the survival MGL and MGL-EV copula respectively.
#' * estimates: the point at which the maximum value of the loglikelihood is obtained.
#' * se: the standard errors of the estimators.
#' * AIC, BIC: the goodness fit of the regression models.
#' * hessian: the hessian at the estimated maximum of the loglikelihood (if requested).
#' @details
#' * Y1: continuous data.
#' * Y2: semi-continuous data where Y2>umin is continuous and Y2<=umin is discrete.
#' * copula: "MGL180" and "MGLEV180" denote the survival MGL and survival MGL-EV copula respectively.
#' * For "Gumbel" regression model, the copula parameter \deqn{\delta_i = \exp(X\beta) + 1.}
#' * For "MGL", "MGL180", "MGL-EV", "MGL-EV180" regression model, the copula parameter \deqn{\delta_i = \exp(X\beta),} where \eqn{\beta} is the vector of coefficients to be estimated in the copula regression.
#'
#'
#'
#' @export
#'
#'
MGL.reg.mixed <- function(obs, U, U_, f, X, copula = c(
"MGL", "MGL180", "MGL-EV",
"MGL-EV180",
"Gumbel"
),
umin = 0,
hessian = TRUE, initpar, ...) {
dcMGL.reg <- function(U, param) {
dim <- length(U)
a <- 1 / param[1]
q <- qbeta(1 - U, shape1 = 0.5, shape2 = a) / (1 - qbeta(1 - U, shape1 = 0.5, shape2 = a))
logdc <- (dim - 1) * lgamma(a) + lgamma(a + dim / 2) - dim * lgamma(a + 0.5) + (a + 0.5) * sum(log(q + 1)) - (a + dim / 2) * log(sum(q) + 1)
out <- exp(logdc)
return(out)
}
dcMGL180.reg <- function(U, param) {
dcMGL.reg(1 - U, param = param)
}
dcMGLEV180.reg <- function(U, param) {
u1 <- U[1]
u2 <- U[2]
as.numeric(dcMGLEV180.bivar(u1, u2, param = param[1]))
}
dcMGLEV.reg <- function(U, param) {
u1 <- U[1]
u2 <- U[2]
as.numeric(dcMGLEV.bivar(u1, u2, param = param[1]))
}
dgumcop.reg <- function(U, param) {
as.numeric(fCopulae::devCopula(u = U[1], v = U[2], type = "gumbel", param = param[1])) # Bivariate Extreme
}
hcMGL.reg <- function(U, param) {
hfunc1 <- hcMGL.bivar(u1 = U[1], u2 = U[2], pars = param[1])$hfunc1
hfunc2 <- hcMGL.bivar(u1 = U[1], u2 = U[2], pars = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hcMGL180.reg <- function(U, param) {
hfunc1 <- 1 - hcMGL.bivar(u1 = 1 - U[1], u2 = 1 - U[2], pars = param[1])$hfunc1
hfunc2 <- 1 - hcMGL.bivar(u1 = 1 - U[1], u2 = 1 - U[2], pars = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hcMGLEV180.reg <- function(U, param) {
hfunc1 <- hcMGLEV180.bivar(u1 = U[1], u2 = U[2], param = param[1])$hfunc1
hfunc2 <- hcMGLEV180.bivar(u1 = U[1], u2 = U[2], param = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hcMGLEV.reg <- function(U, param) {
hfunc1 <- 1 - hcMGLEV180.bivar(u1 = 1 - U[1], u2 = 1 - U[2], param = param[1])$hfunc1
hfunc2 <- 1 - hcMGLEV180.bivar(u1 = 1 - U[1], u2 = 1 - U[2], param = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hgumcop.reg <- function(U, param) {
VineCopula::BiCopHfunc(u1 = U[1], u2 = U[2], family = 4, par = param[1])
}
if (copula == "MGL") {
dcop <- dcMGL.reg
hcop <- hcMGL.reg
} else if (copula == "MGL180") {
dcop <- dcMGL180.reg
hcop <- hcMGL180.reg
} else if (copula == "MGL-EV") {
dcop <- dcMGLEV.reg
hcop <- hcMGLEV.reg
} else if (copula == "MGL-EV180") {
dcop <- dcMGLEV180.reg
hcop <- hcMGLEV180.reg
} else if (copula == "Gumbel") {
dcop <- dgumcop.reg
hcop <- hgumcop.reg
}
# Obs1 <- obs[, 1] # y1 - the first vector of observations
Obs2 <- obs[, 2] # y2 - the second vector of observations
f1 <- f[, 1]
f2 <- f[, 2]
copLogL <- function(pars, X) {
ll <- 0
if (copula == "Gumbel") {
delta <- exp(X %*% pars) + 1
} else {
delta <- exp(X %*% pars)
}
for (i in seq_len(nrow(X))) {
if (Obs2[i] <= umin) {
ll[i] <- f1[i] * (hcop(U[i, ], param = delta[i])$hfunc1 - hcop(U_[i, ], param = delta[i])$hfunc1)
} else {
ll[i] <- f1[i] * f2[i] * dcop(U[i, ], param = delta[i])
}
}
res <- - sum((log(ll)))
return(res)
}
resopt <- optim(
par = initpar,
fn = copLogL,
X = X,
hessian = hessian, ...
)
resopt
list(
loglike = -resopt$value,
copula = list(name = copula),
estimates = resopt$par,
se = sqrt(diag(solve(resopt$hessian))),
hessian = -resopt$hessian,
AIC = 2 * length(resopt$par) + 2 * resopt$value,
BIC = log(nrow(U)) * length(resopt$par) + 2 * resopt$value
)
}
m.MGLMGA180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.MGLMGA180
m.MGLEV180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGLEV180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.MGLEV180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL-EV180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.gumbel <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "Gumbel",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.gumbel
library(rMGLReg)
u <- cbind(earthqCHI$u1, earthqCHI$u2)
u_ <- cbind(earthqCHI$u1, earthqCHI$u2_)
y <- cbind(earthqCHI$y1, earthqCHI$y2)
f <- cbind(earthqCHI$f1, earthqCHI$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
library(splines)
X <- ns(earthqCHI$year, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
m.MGL180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.MGLEV180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL-EV180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.gumbel <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "Gumbel",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
estimates.copula <- rbind((m.MGL180$estimates), (m.MGLEV180$estimates), (m.gumbel$estimates))
sd.copula <- rbind((m.MGL180$se), (m.MGLEV180$se), (m.gumbel$se))
ll.copula <- rbind((m.MGL180)$loglike, (m.MGLEV180)$loglike, (m.gumbel)$loglike)
AIC.copula <- rbind((m.MGL180)$AIC, (m.MGLEV180)$AIC, (m.gumbel)$AIC)
BIC.copula <- rbind((m.MGL180)$BIC, (m.MGLEV180)$BIC, (m.gumbel)$BIC)
table1 <- cbind(estimates.copula, sd.copula, ll.copula, AIC.copula, BIC.copula)
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "se", "se","se",'loglike', 'AIC', 'BIC')
table1
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "se", "se","se",'loglike', 'AIC', 'BIC')
table1
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "estimates", "se", "se", "se","se",'loglike', 'AIC', 'BIC')
knitr::kable(t(table1), digits = 3)
m.MGL180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1))
X
dim(X)
estimates.copula <- rbind((m.MGL180$estimates), (m.MGLEV180$estimates), (m.gumbel$estimates))
sd.copula <- rbind((m.MGL180$se), (m.MGLEV180$se), (m.gumbel$se))
ll.copula <- rbind((m.MGL180)$loglike, (m.MGLEV180)$loglike, (m.gumbel)$loglike)
AIC.copula <- rbind((m.MGL180)$AIC, (m.MGLEV180)$AIC, (m.gumbel)$AIC)
BIC.copula <- rbind((m.MGL180)$BIC, (m.MGLEV180)$BIC, (m.gumbel)$BIC)
table1 <- cbind(estimates.copula, sd.copula, ll.copula, AIC.copula, BIC.copula)
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "estimates", "se", "se", "se","se",'loglike', 'AIC', 'BIC')
knitr::kable(t(table1), digits = 3)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1980, to = 1990)
Xcopula <-  splines::ns(agepred, knots = quantile(dtnew$year, c(0.5)), intercept = T)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(dtnew$year, c(0.333, 0.667)), intercept = T)
par.est
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(dtnew$year, c(0.333, 0.667)), intercept = T)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
??mvrnorm
mvrnorm
library(MASS)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 2), main = 'Survival MGL')
lines(delta.est, col = 'red', lwd = 2)
library(MASS)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 2), main = 'Survival MGL')
lines(delta.est, col = 'red', lwd = 2)
# Surivial MGL-EV regression
par.est <- m.MGLEV180$estimates
agepred <- seq(from = 1980, to = 1990)
Xcopula <-  ns(agepred, knots = quantile(dtnew$year, c(0.5)), intercept = T)
library(MASS)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 2), main = 'Survival MGL')
lines(delta.est, col = 'red', lwd = 2)
# Surivial MGL-EV regression
par.est <- m.MGLEV180$estimates
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGLEV180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 2), main = 'Survival MGL-EV')
lines(delta.est, col = 'red', lwd = 2)
# Gumbel regression
par.est <- m.gumbel$estimates
delta.est <- exp(Xcopula%*%par.est) + 1
cov.est <- -solve(m.gumbel$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,]) + 1
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 2), main = 'Gumbel')
lines(delta.est, col = 'red', lwd = 2)
library(MASS)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Survival MGL')
lines(delta.est, col = 'red', lwd = 2)
# Surivial MGL-EV regression
par.est <- m.MGLEV180$estimates
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGLEV180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Survival MGL-EV')
lines(delta.est, col = 'red', lwd = 2)
# Gumbel regression
par.est <- m.gumbel$estimates
delta.est <- exp(Xcopula%*%par.est) + 1
cov.est <- -solve(m.gumbel$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,]) + 1
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Gumbel')
lines(delta.est, col = 'red', lwd = 2)
?earthqCHI
library(rMGLReg)
library(fitdistrplus)
library(splines)
library(snpar)
data("danishmulti")
dt <- data.table::data.table(danishmulti)
dtnew <- dt[Building>0&Contents>0]
y1 <- dtnew$Building
y2 <- dtnew$Contents
y <- cbind(y1, y2)
# empirical cdf
u1 <- snpar::kde(y[,1], kernel = "gaus",
xgrid = y[,1],
h = 0.2)$Fhat
u2 <- snpar::kde(y[,2], kernel = "gaus",
xgrid = y[,2],
h = 0.2)$Fhat
U <- cbind(u1, u2) # bivariate pseudo copula data.
plot(U)
library(ggplot2)
library(latex2exp)
Usample <- U
XY <- y
newtheme <-   theme_bw() + theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
axis.ticks.length = unit(-0.1, "cm"),
plot.title = element_text(hjust = 0.5),
legend.direction = 'vertical',
legend.position = c(.95, .99),
legend.justification = c("right", "top"),
legend.box.just = "right",
legend.text = element_text(size = 10))
dtplot <- data.frame(U1 = Usample[,1], U2 = Usample[,2],
logY1 = log(XY[,1]), logY2 = log(XY[,2]))
p1 <- ggplot(data = dtplot, mapping = aes(y = logY1,
x = logY2)) +
newtheme +
geom_point() +
labs(title = "",
x = TeX("$log Y_1$"),
y = TeX("$log Y_2$")) +
scale_x_continuous(limits = c(-7.5, 5),
breaks = seq(-7.5, 5, by = 2.5)) +
scale_y_continuous(limits = c(-5, 5),
breaks = seq(-5, 5, by = 2.5))
p1
p2 <- ggplot(data = dtplot, mapping = aes(y = U2,
x = U1)) +
newtheme +
geom_point() +
labs(title = "",
x = TeX("$u_1$"),
y = TeX("$u_2$")) +
scale_x_continuous(limits = c(0, 1),
breaks = seq(0, 1, by = 0.2)) +
scale_y_continuous(limits = c(0, 1),
breaks = seq(0, 1, by = 0.2))
p2
library(patchwork)
p0 <- p1 + p2 + plot_layout(ncol = 2)
p0
p0
library(rMGLReg)
