renv::init()
renv::snapshot()
install.packages("rmarkdown")
usethis::use_readme_rmd()
renv::init()
renv::snapshot()
usethis::use_readme_rmd()
devtools::document()
library(rMGLReg)
install.packages("styler")
styler::style_pkg()
devtools::load_all()
add
?add
devtools::check()
library(rMGLReg)
?dLM
devtools::document()
?dLMGA
?pbeta
?Vectorize
renv::init()
renv::snapshot()
usethis::use_package(package = "renv", type = "Suggests")
install.packages("usethis")
usethis::use_package(package = "renv", type = "Suggests")
requireNamespace("renv", quietly = TRUE)
install.packages("renv")
renv::snapshot()
install.packages("testthat")
install.packages("roxygen2")
renv::snapshot()
y
install.packages("copula")
renv::snapshot()
library(rMGLReg)
devtools::document()
install.packages("devtools")
devtools::document()
?dGLMGA
load_all
install.packages("learnr")
install.packages("pracma")
usethis::use_package(package = "pracma", type = "Imports")
renv::snapshot()
library(rMGLReg)
install.packages("lintr")
lintr::lint_package()
lintr::lint_package()
devtools::document()
?dcGLMGA.multi
?pcGLMGA.multi
dcGLMGA.multi
pcGLMGA.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
# =====================================================================
# 2. cdf if GLMGA copula
# =====================================================================
pcGLMGA <- function(u1, u2, pars) {
library(pracma)
a <- 1/pars
q1 <- qbeta(1-u1, shape1 = 0.5, shape2 = a)/(1 - qbeta(1-u1, shape1 = 0.5, shape2 = a))
q2 <- qbeta(1-u2, shape1 = 0.5, shape2 = a)/(1 - qbeta(1-u2, shape1 = 0.5, shape2 = a))
fin <- function(theta){ # rely on a
m1 <- erfc((q1*theta)^0.5)
m2 <- erfc((q2*theta)^0.5)
out <- m1*m2*theta^(a-1)*exp(-theta)/gamma(a)
out
}
if(u1==0|u2==0){
z <- 0
} else if (u1==1&u2!=0){
z <- u2
} else if (u1!=0&u2==1){
z <- u1
} else {
z <- as.numeric(pracma::integral(fun = fin, xmin = 0, xmax = Inf, method = 'Clenshaw'))
}
return(z) # rely on k
}
pcGLMGA.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
library(rMGLReg)
pcGLMGA.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
pracma::erfc
usethis::use_package(package = "pracma", type = "Imports")
library(rMGLReg)
devtools::document()
pcGLMGA.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
pcGLMGA.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
library(rMGLReg)
pcGLMGA.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
pracma::erfc
devtools::document()
pcGLMGA.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
?pracma::integral
?rcGLMGA.multi
Usim <- rcGLMGA.multi(n = 1000, d = 2, param = 1)
Usim
?dcGLMGA.multi
dcGLMGA.multi(u = cbind(c(0.6, 0.1, 0.5), c(0.3, 0.9, 0.2)), pars = 10, log = FALSE)
dcGLMGA.multi(u = cbind(c(0.6, 0.1), c(0.3, 0.9), c(0.5, 0.6)), pars = 2, log = T)
?rgamma
#' d-dimensional MGL copula
#'
#' @param u d-dimensional matrix
#' @param pars copula parameter, denoted by delta
#' @param log logical; if TRUE, probabilities/densities p are returned as log(p).
#' @param n number of observations. If length(n) > 1, the length is taken to be the number required.
#' @param d d-dimensions
#'
#' @returnDensity, Density, distribution function, and random generation for the d-dimensional MGL copula with copula parameter delta.
#' @export
#'
#' @examples
#' dcGLMGA.multi(u = cbind(c(0.6, 0.1, 0.5), c(0.3, 0.9, 0.2)), pars = 10, log = FALSE)
#' dcGLMGA.multi(u = cbind(c(0.6, 0.1), c(0.3, 0.9), c(0.5, 0.6)), pars = 2, log = T)
#'
#'
#'
dcGLMGA.multi <- function(u, pars, log = FALSE){
# coding as a matrix
dim <- ncol(u)
a <- 1/pars[1]
q <- (qbeta(1-u, shape1 = 0.5, shape2 = a)/(1 - qbeta(1-u, shape1 = 0.5, shape2 = a)))
logdc <- 0
for(i in 1:nrow(u)){
logdc[i] <- (dim - 1)*lgamma(a) + lgamma(a + dim/2) - dim*lgamma(a + 0.5) + (a + 0.5)*sum(log(q[i,] + 1)) - (a + dim/2)*log(sum(q[i,]) + 1)
}
dc <- exp(logdc)
dc[which(q == Inf)] <- 0
if(log == TRUE) {logdc} else {dc}
}
#' d-dimensional MGL copula
#'
#' @param u d-dimensional matrix
#' @param pars copula parameter, denoted by delta
#' @param log logical; if TRUE, probabilities/densities p are returned as log(p).
#'
#' @returnDensity, Density, distribution function, and random generation for the d-dimensional MGL copula with copula parameter delta.
#' @export
#'
#' @examples
#' pcGLMGA.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
#'
#'
#'
pcGLMGA.multi <- function(u, pars) {
dim <- ncol(u)
a <- 1/pars[1]
q <- (qbeta(1-u, shape1 = 0.5, shape2 = a)/(1 - qbeta(1-u, shape1 = 0.5, shape2 = a)))
z <- 0
for(i in 1:nrow(u)){
fin <- function(theta){ # rely on a
m <- pracma::erfc((q[i,]*theta)^0.5)
k <- prod(m)
out <- k*theta^(a-1)*exp(-theta)/gamma(a)
out
}
z[i] <- as.numeric(pracma::integral(fun = fin,
xmin = 0,
xmax = Inf, method = 'Clenshaw'))
}
return(z) # rely on k
}
#' d-dimensional MGL copula
#'
#' @param u d-dimensional matrix
#' @param pars copula parameter, denoted by delta
#' @param log logical; if TRUE, probabilities/densities p are returned as log(p).
#'
#' @returnDensity, Density, distribution function, and random generation for the d-dimensional MGL copula with copula parameter delta.
#' @export
#'
#' @examples
#' Usim <- rcGLMGA.multi(n = 1000, d = 2, param = 1)
#' Usim
#'
rcGLMGA.multi <- function(n, d, param){
a <- 1/param
dseq <- seq(1:(d-1))
anew <- c(a, a + dseq/2)
Iinv_trans <- function(u, a) {
qbeta(1 - u, shape1 = 0.5, shape2 = a)/(1 - qbeta(1 - u, shape1 = 0.5, shape2 = a))
}
umat <- matrix(data = runif(n*d, min = 0, max = 1), nrow = n, ncol = d)
mmat <- qmat <- zmat <- Usim <- matrix(data = 0, nrow = n, ncol = d)
for(j in 1:ncol(umat)){
qmat[,j] <- Iinv_trans(umat[,j], a = anew[j]) # column j denots the qj
}
mmat[,1] <- qmat[, 1]
mmat[,2] <- (1 + mmat[,1])*qmat[, 2]
if(d >2){
for(j in 3:ncol(umat)){
tempmat <- mmat[, (1):(ncol(umat)-1)]
if(n == 1 ){
msum <- sum(tempmat)
} else {
msum <- apply(tempmat, MARGIN = 1, sum)
}
mmat[,j] <- (1 + msum)*qmat[, j]
}
}
for(j in 1:ncol(zmat)){
k <- mmat[,j]/(mmat[,j] + 1)
Usim[, j] <- 1 - pbeta(k, shape1 = 0.5, shape2 = a)
}
return(Usim)
}
dcGLMGA.multi
library(rMGLReg)
devtools::document()
rm(list = c("dcGLMGA.multi", "pcGLMGA.multi", "rcGLMGA.multi"))
library(rMGLReg)
devtools::document()
?rcGLMGA.multi
?dcGLMGA.multi
ï¼Ÿqbeta
?qbeta
usethis::use_package(package = "stats", type = "Imports")
?runif
styler::style_pkg()
library(rMGLReg)
devtools::document()
install.packages("VineCopula")
?BiCopHfunc
library(VineCopula)
?BiCopHfunc
renv::restore()
usethis::use_test()
library(rMGLReg)
library(rMGLReg)
?pcMGL.multi
?dcopula
dCopula
library(copula)
dcopula
?dcopula
?dcMGL.bivar
?hMGL.bivar
hMGL.bivar(u1 = c(0.1, 0.001, 0.3), u2 = c(0, 0.9999, 0.88), pars = 2)
install.packages("roxygen2")
Usim <- rcMGL.multi(n = 1000, d = 2, param = 1)
Usim
usethis::use_mit_license()
devtools::check()
install.packages("pkgdown")
usethis::use_pkgdown()
pkgdown::build_site()
devtools::document()
library(rMGLReg)
devtools::document()
?hcMGL.bivar
styler::style_pkg()
install.packages("styler")
styler::style_pkg()
devtools::document()
library(root)
install.packages("root")
devtools::document()
search()
?importFrom
??importFrom
devtools::document()
library(rMGLReg)
?hcMGB2.bivar
?pcMGB2.bivar
pCopula
library(copula)
pCopula
?pCopula
usethis::use_data_raw(name = 'danish')
file.create("R/data.R")
usethis::use_git()
library(fitdistrplus)
library(data.table)
data("danishmulti")
dt <- data.table(danishmulti)
dt[, year := as.numeric(substr(Date, start = 1, stop = 4)) - 1979]
dtnew <- dt[Building>0&Contents>0]
y1 <- dtnew$Building
y2 <- dtnew$Contents
XY <- cbind(y1, y2)
data("danishmulti")
install.packages("fitdistrplus")
data("danishmulti")
dt <- data.table(danishmulti)
danishmulti
data("danishmulti")
library(fitdistrplus)
devtools::use_vignette("introduction")
pcGLMGA180
library(rMGLReg)
?rcMGL.multi
?rcMGL180
devtools::document()
library(rMGLReg)
?rcMGL180.bivar
dcMGL180.bivar(u1 = 0.001, u2 = 0.999, pars = 1)
pcMGL180.bivar(u1 = c(0.6, 0.1, 0.7), u2 = c(0.3, 0.6, 0.9), pars = 5)
Usim <- rcMGL180.bivar(5000, param = 7)
plot(Usim)
rcMGL180.bivar(5000, param = 7)
rcMGL180.bivar(5000, param = 3)
rcMGL180.bivar(5000, param = 3)
rcMGL180.bivar(5000, param = 3)
