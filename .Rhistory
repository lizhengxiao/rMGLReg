<<<<<<< Updated upstream
pars <- c(coef(m.NB, what = 'mu'), coef(m.NB, what = 'sigma'))
summary1 <- summary(m.NB)
summary(m.NB)
logLik(m.NB)
mu.NB <- exp(coef(m.NB))
sigma.NB <- exp(coefficients(m.NB, what = 'sigma'))
par(mfrow = c(1, 2), tcl = 0.3, mgp = c(1.5,0,0))
res.death <- residuals(m.NB, what = 'z-scores')
qqnorm(res.death, ylim = c(-3,3), xlim = c(-3,3), main = '')
abline(0,1, col = 'red')
# death > umin
X1 <- model.matrix( ~ 1, data = dtnew[y2>umin])
X2 <- model.matrix( ~ 1,  data = dtnew[y2>umin])
y2new <- dtnew[y2>umin]$y2
GPD.MLE <- fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
GPD.MLE
# plot(GPD.MLE)
GPD.par <- GPD.MLE$results$par
pars <- GPD.MLE$results$par
GPD.hessian <- GPD.MLE$results$hessian
GPD.se <- sqrt(diag(solve(GPD.hessian)))
GPD.Z = GPD.par/GPD.se                                            ##  Z统计???
GPD.p = ifelse(GPD.Z>=0, pnorm(GPD.Z, lower=F)*2, pnorm(GPD.Z)*2)    ## p???
cbind(GPD.par, GPD.se, GPD.p)
scale <- (X1%*%pars[1:dim(X1)[2]])
shape <- X2%*%pars[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]
ufit <- 0
for(i in 1:length(y2new)){
ufit[i] <- evd::pgpd(y2new[i], loc = umin, scale = scale[i], shape = shape[i])
=======
#' @md
#' @return A list containing the following components:
#' * minimum   the value of the estimated minimum of f.
#' * estimate	  the point at which the minimum value of f is obtained.
#' * gradient	the gradient at the estimated minimum of f.
#' * hessian	the hessian at the estimated minimum of f (if requested).
#' @export
#'
#'
#'
MGL.mle <- function(U, copula = c('MGL', 'MGL180', "MGL-EV",
"MGL-EV180",
"Gumbel",
"Normal", "MGB2", "t"
),
initpar, ...){
dnormcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
dtcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "t",
param = param[2]))  # t copula
dgumcop <- function(U, param)
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param){
as.numeric(dcMGLEV(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
} else if(copula == "MGB2"){
dcop <- dMGB2
arg.cop <- argMGB2
}
# loglike.copula <- function(U, initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000}
return(res)}
# }
resopt <- nlm(f = copLogL,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = F)
# resopt
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
}
#
# m.MGLMGA180 <- MGL.mle(U,
#                        copula  = "MGL180",
#                        initpar = c(0.5))
m.MGLMGA180 <- MGL.mle(U,
copula  = "MGL180",
initpar = c(1))
MGL.mle
#' Fitting bivariate MGL copula models
#'
#' @description MGL.reg is used to fit bivariate MGL copula regression models.
#' @param U two-dimenstional matrix with values in [0,1].
#' @param X design matrix
#' @param copula 'MGL', 'MGL180', "MGL-EV", "MGL-EV180", "MGB2", "Normal" , "Student-t"
#' @param initpar Initial values for the parameters to be optimized over.
#' @param ... 		additional arguments to be passed to f.
#' @md
#' @return A list containing the following components:
#' * minimum   the value of the estimated minimum of f.
#' * estimate	  the point at which the minimum value of f is obtained.
#' * gradient	the gradient at the estimated minimum of f.
#' * hessian	the hessian at the estimated minimum of f (if requested).
#' @export
#'
#'
#'
MGL.mle <- function(U, copula = c('MGL', 'MGL180', "MGL-EV",
"MGL-EV180",
"Gumbel",
"Normal", "MGB2", "t"
),
initpar, ...){
dnormcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
dtcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "t",
param = param[2]))  # t copula
dgumcop <- function(U, param)
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param){
as.numeric(dcMGLEV(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
} else if(copula == "MGB2"){
dcop <- dMGB2
arg.cop <- argMGB2
>>>>>>> Stashed changes
}
resGPD.death <- qnorm(ufit)
qqnorm(resGPD.death, ylim = c(-3, 3), xlim = c(-3, 3),
main = '')
abline(0, 1, col = 'red')
# ======================================================================================
# GPD and negative binom
y <- dtnew$y2
dtnew
y2new
y2new <- dtnew[y2>umin]$y2
GPD.MLE <- fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
??fevd
install.packages("extRemes")
GPD.MLE <- extRemes::fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
GPD.MLE
# plot(GPD.MLE)
GPD.par <- GPD.MLE$results$par
pars <- GPD.MLE$results$par
GPD.hessian <- GPD.MLE$results$hessian
GPD.se <- sqrt(diag(solve(GPD.hessian)))
GPD.Z = GPD.par/GPD.se                                            ##  Z统计???
GPD.p = ifelse(GPD.Z>=0, pnorm(GPD.Z, lower=F)*2, pnorm(GPD.Z)*2)    ## p???
cbind(GPD.par, GPD.se, GPD.p)
# plot(GPD.MLE)
GPD.par <- GPD.MLE$results$par
pars <- GPD.MLE$results$par
scale <- (X1%*%pars[1:dim(X1)[2]])
shape <- X2%*%pars[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]
ufit <- 0
for(i in 1:length(y2new)){
ufit[i] <- evd::pgpd(y2new[i], loc = umin, scale = scale[i], shape = shape[i])
}
<<<<<<< Updated upstream
resGPD.death <- qnorm(ufit)
qqnorm(resGPD.death, ylim = c(-3, 3), xlim = c(-3, 3),
main = '')
abline(0, 1, col = 'red')
## ----echo=TRUE, message=FALSE, warning=FALSE------------
library(gamlss)
library(gamlss.tr)
library(extRemes)
library(pracma)
library(VineCopula)
library(data.table)#
library(actuar)
library(evd)
library(fCopulae)
library(ggplot2)
# source('0. definition of MGLMGA copula.r')
# source('0. definition of brivariate copula.r')
newtheme <-   theme_bw() + theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
axis.ticks.length = unit(-0.1, "cm"),
plot.title = element_text(hjust = 0.5),
legend.direction = 'vertical',
legend.position = c(.95, .99),
legend.justification = c("right", "top"),
legend.box.just = "right",
legend.text = element_text(size = 10))
## ----message=TRUE, warning=FALSE------------------------
dtnew <- fread('dtnew_copula.csv')
dtnew$ynew <- NULL
dtnew <- dtnew[year %in% seq(1990, 2015)]
dtadjust <- fread('dtcpi.csv', header = T)
dtadjust <- dtadjust[year %in% seq(1990, 2015)]
dtadjust
dtadjust[, CPI_factor := 1/(CPI/615.2)]
setkey(dtadjust, year)
setkey(dtnew, year)
dt <- merge(dtnew, dtadjust)
dt[is.na(y)]$y <- median(dt$y, na.rm = T)
dt[, ynew := y*CPI_factor]
dtnew <- dt[,.(year,
yraw = y,
#location = ,
y1 = ynew, magnitude, death, inj,intensity,
log.area, log.population,
y2 = death + inj)]
dtnew
# dtnew[is.na(log.area)]$log.area <- mean(dt$log.area, na.rm = T)
# dtnew[is.na(log.population)]$log.population <- mean(dt$log.population, na.rm = T)
# dtnew[is.na(intensity)]$intensity <- median(dt$intensity, na.rm = T)
# dtnew[order(y1)]
# tail(dtnew[order(yraw)])
# dtnew <- dtnew[y2>0]
# # =============================================================================
# # difine the hessian matrix output and the stardard error -------------------------------------------------
# modout <- function(m) {
#   Hessian <- m$hessian
#   se <- sqrt(diag(solve(Hessian)))                  ## 标准???
#   Z <- m$par/se                                             ##  Z统计???
#   p <- ifelse(Z>=0, pnorm(Z, lower=F)*2, pnorm(Z)*2)           ## p???
#   summarytable <- round(data.frame(m$par, se, Z, p), 3)
#   NLL <- m$value  # - loglikelihood value
#   AIC <- 2*length(m$par) + 2*NLL
#   BIC <- log((nrow(dtnew)))*length(m$par) + 2*NLL
#   list(summary = summarytable, ll =  - m$value, AIC = AIC, BIC = BIC)
# }
y <- dtnew$y1
modout <- function(m) {
Hessian <- m$hessian
se <- sqrt(diag(solve(Hessian)))                  ## stardard error
Z <- m$par/se                                             ##  Z statistic
p <- ifelse(Z>=0, pnorm(Z, lower=F)*2, pnorm(Z)*2)           ## p value
summarytable <- round(data.frame(m$par, se, Z, p), 3)
NLL <- m$value  # - loglikelihood value
AIC <- 2*length(m$par) + 2*NLL
BIC <- log(length(y))*length(m$par) + 2*NLL
list(summary = summarytable, ll =  - m$value, AIC = AIC, BIC = BIC)
}
# # define a new function
# remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)] # 去除 NA ?????? ??? 无限???
## ----message=TRUE, warning=FALSE------------------------
# -------------------------------------------------------------
# GLMGA III distribution
# -------------------------------------------------------------
y <- dtnew$y1
# Xsigma <- model.matrix(~ magnitude, data = dtnew);
# Xb <- model.matrix(~ intensity, data = dtnew)
Xsigma <- model.matrix(~ 1, data = dtnew);
Xb <- model.matrix(~ 1, data = dtnew)
LLlogmoyalGA3 <- function(y, pars, Xsigma, Xb) {
sigma <- exp(Xsigma %*% pars[1:dim(Xsigma)[2]])
b <- exp(Xb %*%pars[(dim(Xsigma)[2]+1):(dim(Xsigma)[2] + dim(Xb)[2])])
a <- exp(pars[dim(Xsigma)[2] + dim(Xb)[2]+1])
ll <- -0.5*log(2*pi) - log(sigma) + a*log(b) + lgamma(a + 0.5) - lgamma(a) - (1/(2*sigma)+1)*log(y) - (a + 0.5)*log(0.5*(1/y)^(1/sigma) + b)
loglike <- -sum(ll)
return(loglike)
}
mlogmoyalGA3 <- optim(fn = LLlogmoyalGA3, Xsigma = Xsigma,
Xb = Xb,
y = y, hessian = T,
control = list(maxit = 50000),
#method = 'Nelder-Mead',
#par = c(-1,-0.1,0.5,-2,-1))
par = c(-1,-1,-1))
modout(mlogmoyalGA3)
#
pars <- mlogmoyalGA3$par
sigma <- exp(Xsigma %*% pars[1:dim(Xsigma)[2]])
b <- exp(Xb %*%pars[(dim(Xsigma)[2]+1):(dim(Xsigma)[2] + dim(Xb)[2])])
a <- exp(pars[dim(Xsigma)[2] + dim(Xb)[2]+1])
ufit <- c()
for(i in 1:length(y)){
ufit[i] <- pLMGA(y[i], sigma = sigma[i], a = a, b = b[i])
}
resLMGA3 <- qnorm(ufit)
modout(mlogmoyalGA3)
u1 <- ufit
f1 <- c()
for(i in 1:length(y)){
f1[i] <- dLMGA(y[i], sigma = sigma[i], a = a, b = b[i])
}
#X <- model.matrix(~ magnitude + intensity, data = dtnew)
#
# X <- model.matrix(~ 1, data = dtnew)
# LLpareto <- function(pars, y, X){
#   lengthpar <- dim(X)[2]
#   beta <- exp(pars[lengthpar+1])
#   sigma <- exp(X%*%pars[1:lengthpar])
#   logL <- log(beta) + beta*log(sigma) - (beta+1)*log(y+sigma) # log-likelihood
#   ll <- -sum(logL)
#   return(ll)
# }
# mlpareto <- optim(fn = LLpareto,
#                   y = y, X = X,
#                   par = rep(times = (dim(X)[2]+1), x = 0.1), hessian = T)
# modout(mlpareto)
# pars <- mlpareto$par
# lengthpar <- dim(X)[2]
# beta <- exp(pars[lengthpar+1])
# sigma <- exp(X%*%pars[1:lengthpar])
# #u1 <- ufit
# f1 <- ufit <- c()
# for(i in 1:length(y)){
#   f1[i] <- dpareto2(y[i], shape = beta, scale = sigma[i])
#   ufit[i] <- ppareto2(y[i], shape = beta, scale = sigma[i])
# }
# respareto <- qnorm(ufit)
# u1 <- ufit
## ----message=TRUE, warning=FALSE------------------------
umin <- 20
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'NBI')
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'PO')
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'ZINBI')
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'ZIP')
dt2 <- dtnew[y2 <= umin]
m.NB <- gamlss(y2 ~ 1, family = NBItr, data = dt2, method = mixed(2, 10000))
summary(m.NB)
pars <- c(coef(m.NB, what = 'mu'), coef(m.NB, what = 'sigma'))
summary1 <- summary(m.NB)
summary(m.NB)
logLik(m.NB)
mu.NB <- exp(coef(m.NB))
sigma.NB <- exp(coefficients(m.NB, what = 'sigma'))
par(mfrow = c(1, 2), tcl = 0.3, mgp = c(1.5,0,0))
res.death <- residuals(m.NB, what = 'z-scores')
qqnorm(res.death, ylim = c(-3,3), xlim = c(-3,3), main = '')
abline(0,1, col = 'red')
# death > umin
X1 <- model.matrix( ~ 1, data = dtnew[y2>umin])
X2 <- model.matrix( ~ 1,  data = dtnew[y2>umin])
y2new <- dtnew[y2>umin]$y2
GPD.MLE <- fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
GPD.MLE
# plot(GPD.MLE)
GPD.par <- GPD.MLE$results$par
pars <- GPD.MLE$results$par
GPD.hessian <- GPD.MLE$results$hessian
GPD.se <- sqrt(diag(solve(GPD.hessian)))
GPD.Z = GPD.par/GPD.se                                            ##  Z统计???
GPD.p = ifelse(GPD.Z>=0, pnorm(GPD.Z, lower=F)*2, pnorm(GPD.Z)*2)    ## p???
cbind(GPD.par, GPD.se, GPD.p)
scale <- (X1%*%pars[1:dim(X1)[2]])
shape <- X2%*%pars[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]
ufit <- 0
for(i in 1:length(y2new)){
ufit[i] <- evd::pgpd(y2new[i], loc = umin, scale = scale[i], shape = shape[i])
}
resGPD.death <- qnorm(ufit)
qqnorm(resGPD.death, ylim = c(-3, 3), xlim = c(-3, 3),
main = '')
abline(0, 1, col = 'red')
# ======================================================================================
# GPD and negative binom
y <- dtnew$y2
X0 <- model.matrix(~ 1, data = dtnew)
X1 <- model.matrix( ~ 1, data = dtnew) # GP
X2 <- model.matrix( ~ 1, data = dtnew) # GP
par1 <- GPD.MLE$results$par
par2 <-  c(coef(m.NB, what = 'mu'), coef(m.NB, what = 'sigma'))
p1 <- nrow(dt2)/nrow(dtnew)
scale <- X1%*%par1[1:dim(X1)[2]]
shape <- X2%*%par1[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]
dtu2 <- data.table(mu = as.vector(exp(X0%*%par2[1:dim(X0)[2]])),
sigma = exp(par2[length(par2)]),
scale = as.vector(X1%*%par1[1:dim(X1)[2]]),
shape = as.vector(X2%*%par1[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]),
y = y, y_ = y - 1,
y__ = y - 2)
dtu2[y_<0]$y_ <- 0
dtu2[y__<0]$y__ <- 0
dtu2
u <- with(dtu2, {
u2 <- u2_ <- u2__ <- u0 <- 0
for(i in 1:length(y)){
if(y[i] <= umin){ u2[i] <- p1*as.vector(pNBItr(y[i], mu = mu[i], sigma = sigma[i]))}
else{ u2[i] <- p1 + (1-p1)*evd::pgpd(y[i], loc = umin, scale = scale[i], shape = shape[i])}
if(y_[i] <= umin){ u2_[i] <- p1*as.vector(pNBItr(y_[i], mu = mu[i], sigma = sigma[i]))}
else{ u2_[i] <- p1 + (1-p1)*evd::pgpd(y_[i], loc = umin, scale = scale[i], shape = shape[i])}
if(y__[i] <= umin){ u2__[i] <- p1*as.vector(pNBItr(y__[i], mu = mu[i], sigma = sigma[i]))}
else{ u2__[i] <- p1 + (1-p1)*evd::pgpd(y__[i], loc = umin, scale = scale[i], shape = shape[i])}
u0 <- pNBItr(umin, mu = mu[i], sigma = sigma[i])
}
u <- cbind(u2, u2_, u2__, u0)
u
})
u2 <- u[,1]
u2_ <- u[,2]
u2__ <- u[,3]
u2_[which(dtnew$y2 - 1 < 0)] <- 0
u2__[which(dtnew$y2 - 2 < 0)] <- 0
dtu2$u2 <- u2
dtu2$u2_ <- u2_
dtu2$u2__ <- u2__
dtu2
# =========================================================================================
# density of y2 --------------------------------------------------------------------------
dtu2$f2 <- with(dtu2, {
f <- 0
for(i in 1:length(y)){
if(y[i] <= umin){
f[i] <- p1*as.vector(dNBItr(y[i], mu = mu[i], sigma = sigma[i]))}
else{
f[i] <- (1-p1)*evd::dgpd(y[i], loc = umin, scale = scale[i], shape = shape[i])}
}
f
})
f2 <- dtu2$f2
## ----message=TRUE, warning=FALSE------------------------
head(cbind(u1,u2))
head(cbind(f1,f2))
head(u2_)
y2
dt2
?fevd
umin
dtnew
GPD.MLE <- extRemes::fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
GPD.MLE
dcMGLEV180.bivar
install.packages("VineCopula")
library(rMGLReg)
library(rMGLReg)
hcMGL.bivar
hcMGL180.bivar
hcMGL180.bivar
hcMGL180.bivar
hcMGL.bivar
hMGLEV180.bivar
library(rMGLReg)
hcMGL.bivar
install.packages("qpfg")
install.packages("qpdf")
usethis::use_package(package = "qpdf", type = "Suggests")
hMGLEV180.bivar
usethis::use_package(package = "VineCopula", type = "Suggests")
library(rMGLReg)
?MGL.mle.mixed
m.norm <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Normal", method = "L-BFGS-B",
initpar = 0.2)
y
y
u <- cbind(earth_model$u1, earth_model$u2)
u_ <- earth_model$u2_
y <- cbind(earth_model$y1, earth_model$y2)
f <- cbind(earth_model$f1, earth_model$f2)
obs <- y
U <- u
U_ <- u_
m.norm <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Normal", method = "L-BFGS-B",
initpar = 0.2)
umin <- 20
m.norm <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Normal", method = "L-BFGS-B",
initpar = 0.2)
U_
u <- cbind(earth_model$u1, earth_model$u2)
u_ <- cbind(earth_model$u1, earth_model$u2_)
y <- cbind(earth_model$y1, earth_model$y2)
f <- cbind(earth_model$f1, earth_model$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
m.norm <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Normal", method = "L-BFGS-B",
initpar = 0.2)
m.t <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "t", method = "L-BFGS-B",
initpar = c(0.1,3))
m.gumbel <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Gumbel",  method = "L-BFGS-B",
initpar = c(2))
m.MGLMGA180 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGL180",  method = "L-BFGS-B",
initpar = c(2))
hcMGL.bivar
m.MGB2 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGB2",  method = "L-BFGS-B",
initpar = c(1, 4, 0.4))
m.MGLEV180 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGLEV180",  method = "L-BFGS-B",
initpar = c(0.2))
m.MGLEV180 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGL-EV180",  method = "L-BFGS-B",
initpar = c(0.2))
m.MGLEV180
library(rMGLReg)
library(rMGLReg)
library(fitdistrplus)
library(splines)
data("danishmulti")
dt <- data.table::data.table(danishmulti)
dt[, year := as.numeric(substr(Date, start = 1, stop = 4))]
dtnew <- dt[Building>0&Contents>0]
y1 <- dtnew$Building
y2 <- dtnew$Contents
XY <- cbind(y1, y2)
y <- cbind(y1, y2)
m1 <- sROC::kCDF(y[,1], bw = 0.2, xgrid = sort(y[,1]))
m2 <- sROC::kCDF(y[,2], bw = 0.2, xgrid = sort(y[,2]))
x <- cbind(m1$x, m2$x)
u1 <- m1$Fhat;y1 <- y[,1]
u1[order(y1)] <- m1$Fhat
u2 <- m2$Fhat; y2 <- y[,2]
u2[order(y2)] <- m2$Fhat
U <- cbind(u1, u2) # empirical cdf
Usample <- U
library(rMGLReg)
# devtools::load_all()
u <- cbind(earth_model$u1, earth_model$u2)
u_ <- cbind(earth_model$u1, earth_model$u2_)
y <- cbind(earth_model$y1, earth_model$y2)
f <- cbind(earth_model$f1, earth_model$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
m.norm <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Normal", method = "L-BFGS-B",
initpar = 0.2)
m.t <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "t", method = "L-BFGS-B",
initpar = c(0.1,3))
m.gumbel <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Gumbel",  method = "L-BFGS-B",
initpar = c(2))
m.MGLMGA180 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGL180",  method = "L-BFGS-B",
initpar = c(2))
m.MGB2 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGB2",  method = "L-BFGS-B",
initpar = c(1, 4, 0.4))
m.MGLEV180 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGL-EV180",  method = "L-BFGS-B",
initpar = c(0.2))
recap <- function(x){
res <- c(alpha = x$estimates,
se = x$se,
loglike = x$loglike,
AIC = x$AIC, BIC = x$BIC)
if(length(res) < 6)
res <- c(res[1], NA, NA,res[2], NA, NA, res[3:5])
if (length(res) > 6 & length(res) < 9)
res <- c(res[1:2], NA, res[3:4], NA, res[5:7])
res <- as.matrix(res)
colnames(res) <- x$copula$name
res}
res.all <- round(cbind(recap(m.norm),
recap(m.t),
recap(m.gumbel),
recap(m.MGLMGA180),
recap(m.MGB2),
recap(m.MGLEV180)
), 4)
out.com <- t(res.all)
out.com <- out.com[order(out.com[,9], decreasing = T),]
knitr::kable(out.com, digits = 2)
recap <- function(x){
res <- c(alpha = x$estimates,
se = x$se,
loglike = x$loglike,
AIC = x$AIC, BIC = x$BIC)
if(length(res) < 6)
res <- c(res[1], NA, NA,res[2], NA, NA, res[3:5])
if (length(res) > 6 & length(res) < 9)
res <- c(res[1:2], NA, res[3:4], NA, res[5:7])
res <- as.matrix(res)
colnames(res) <- x$copula$name
res}
res.all <- round(cbind(recap(m.norm),
recap(m.t),
recap(m.gumbel),
recap(m.MGLMGA180),
recap(m.MGB2),
recap(m.MGLEV180)
), 4)
out.com <- t(res.all)
out.com <- out.com[order(out.com[,9], decreasing = T),]
knitr::kable(out.com, digits = 3)
renv::status()
install.packages("rmarkdown")
install.packages("roxygen2")
install.packages("pracma")
install.packages("fCopulae")
install.packages("devtools")
=======
#
# m.MGLMGA180 <- MGL.mle(U,
#                        copula  = "MGL180",
#                        initpar = c(0.5))
knitr::kable(out.com[order(out.com[,9]),], digits = 3)
out.com[order(out.com[,9]),]
out.com <- t(res.all)
out.com <- out.com[order(out.com[,9]),]
knitr::kable(out.com, digits = 3)
knitr::kable(out.com, digits = 2)
?order
out.com <- out.com[order(out.com[,9], decreasing = T)]
out.com
out.com <- out.com[order(out.com[,9], decreasing = T),]
out.com <- t(res.all)
out.com <- out.com[order(out.com[,9], decreasing = T),]
out.com
knitr::kable(out.com, digits = 2)
MGL.mle
MGL.mle
m.MGB2 <- MGL.mle(U,
copula  = "MGB2",
initpar = c(0.1, 2, 0.4))
m.MGLMGA180 <- MGL.mle(U,
copula  = "MGL180",
initpar = c(1))
m.MGB2 <- MGL.mle(U,
copula  = "MGB2",
initpar = c(0.1, 2, 0.4))
m.MGB2 <- MGL.mle(U,
copula  = "MGB2",
initpar = c(0.1, 2, 0.4))
m.MGLEV180 <- MGL.mle(U,
copula  = "MGL-EV180",
initpar = c(2))
m.MGLEV180 <- MGL.mle(U,
copula  = "MGL-EV180",
initpar = c(2))
m.norm <- MGL.mle(U = U,
copula  = "Normal",
initpar = 0.5)
devtools::document()
rm(list = c("MGL.mle"))
devtools::document()
library(rMGLReg)
? earthqCHI
？hcMGL.bivar
?hcMGL.bivar
usethis::use_vignette("counter-plot-MGLMGA")
library(rMGLReg)
devtools::load_all(".")
dMGLMGA
library(rMGLReg)
library(ggplot2)
library(latex2exp)
library(data.table)
# =======================================================================
# Case I:
# sigma <- c(0.5, 0.5)
# a <- 20
# b <- c(5, 5)
# =======================================================================
n.grid <- 500
sigma <- c(0.5, 0.5)
a <- 20
b <- c(5, 5)
xgrid <- ygrid <- seq(0.01, 20, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d[,1] <- grid[,1]
mtrx3d[,2] <- grid[,2]
for(i in 1:nrow(mtrx3d)){
mtrx3d[i,3] = dMGLMGA(y1 = grid[i,1], y2 = grid[i,2],
sigma = sigma,
a = a, b = b)
}
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
bins <- 10
sigma1 <- sigma[1]; sigma2 <- sigma[2]
b1 <- b[1]; b2 <- b[2]
Nsim <- 1000
u1sim <- runif(Nsim, min = 0, max = 1)
y1sim <- qLMGA(u1sim, sigma = sigma1, a = a, b = b1)
library(rMGLReg)
library(ggplot2)
library(latex2exp)
library(data.table)
# =======================================================================
# Case I:
# sigma <- c(0.5, 0.5)
# a <- 20
# b <- c(5, 5)
# =======================================================================
n.grid <- 500
sigma <- c(0.5, 0.5)
a <- 20
b <- c(5, 5)
xgrid <- ygrid <- seq(0.01, 20, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d[,1] <- grid[,1]
mtrx3d[,2] <- grid[,2]
for(i in 1:nrow(mtrx3d)){
mtrx3d[i,3] = dMGLMGA(y1 = grid[i,1], y2 = grid[i,2],
sigma = sigma,
a = a, b = b)
}
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
bins <- 10
sigma1 <- sigma[1]; sigma2 <- sigma[2]
b1 <- b[1]; b2 <- b[2]
Nsim <- 1000
u1sim <- runif(Nsim, min = 0, max = 1)
y1sim <- qGLMGA(u1sim, sigma = sigma1, a = a, b = b1)
anew <- a + 0.5; b2new <- b2*(1 + y1sim^(-1/sigma1)/(2*b1))
y2sim <- NA
for(i in 1:Nsim){
y2sim[i] <- rLMGA(1, sigma = sigma2, a = anew, b = b2new[i])
}
library(rMGLReg)
qGLMGA
library(rMGLReg)
library(ggplot2)
library(latex2exp)
library(data.table)
# =======================================================================
# Case I:
# sigma <- c(0.5, 0.5)
# a <- 20
# b <- c(5, 5)
# =======================================================================
n.grid <- 500
sigma <- c(0.5, 0.5)
a <- 20
b <- c(5, 5)
xgrid <- ygrid <- seq(0.01, 20, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d[,1] <- grid[,1]
mtrx3d[,2] <- grid[,2]
for(i in 1:nrow(mtrx3d)){
mtrx3d[i,3] = dMGLMGA(y1 = grid[i,1], y2 = grid[i,2],
sigma = sigma,
a = a, b = b)
}
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
bins <- 10
sigma1 <- sigma[1]; sigma2 <- sigma[2]
b1 <- b[1]; b2 <- b[2]
Nsim <- 1000
u1sim <- runif(Nsim, min = 0, max = 1)
y1sim <- qGLMGA(u1sim, sigma = sigma1, a = a, b = b1)
anew <- a + 0.5; b2new <- b2*(1 + y1sim^(-1/sigma1)/(2*b1))
y2sim <- NA
for(i in 1:Nsim){
y2sim[i] <- rGLMGA(1, sigma = sigma2, a = anew, b = b2new[i])
}
rGLMGA
qGLMGA
?qGLMGA
library(rMGLReg)
qGLMGA
library(rMGLReg)
load.all()
devtools::load_all()
>>>>>>> Stashed changes
