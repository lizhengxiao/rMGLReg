dcMGL.multi(u = cbind(c(0.6, 0.1), c(0.3, 0.9), c(0.5, 0.6)), pars = 2, log = T)
?pcMGL.multi
？nlm
?nlm
?qbeta
?optim
?runif
renv::snapshot()
earthqCHI
data(earthqCHI)
earthqCHI
?dcMGL.multi
library(rMGLReg)
?dcMGL.multi
?dgamma
?dcMGL.multi
?rcMGL180.multi
library(rMGLReg)
?dcMGL.multi
?dcMGL.multi
?dGLMGA
?pcMGLEV.bivar
styler::style_pkg()
?hcMGB2.bivar
?optim
?MGL.mle
library(rMGLReg)
?MGL.mle
?pcMGLEV.bivar
?rgamma
?cMGL.multi
?dcMGLEV180.bivar
?pcMGLEV.bivar
？dcMGL.bivar
?dcMGL.bivar
?dcMGL180.bivar
?rgamma
?dcMGL.bivar
library(rMGLReg)
library(rMGLReg)
library(rMGLReg)
?dcMGL.bivar
devtools::load_all()
library(data.table)
library(rMGLReg)
dtnew <- fread('D:/Rpackages/rMGLReg/data-raw/dtnew_copula.csv')
dtnew$ynew <- NULL
dtnew <- dtnew[year %in% seq(1990, 2015)]
dtadjust <- fread('D:/Rpackages/rMGLReg/data-raw/dtcpi.csv', header = T)
dtadjust <- dtadjust[year %in% seq(1990, 2015)]
dtadjust
dtadjust[, CPI_factor := 1/(CPI/615.2)]
setkey(dtadjust, year)
setkey(dtnew, year)
dt <- merge(dtnew, dtadjust)
dt[is.na(y)]$y <- median(dt$y, na.rm = T)
dt[, ynew := y*CPI_factor]
dtnew <- dt[,.(year,
yraw = y,
y1 = ynew, magnitude, death, inj,intensity,
y2 = death + inj)]
dtnew
# marginal distribution for y1
y <- dtnew$y1
Xsigma <- model.matrix(~ 1, data = dtnew);
Xb <- model.matrix(~ 1, data = dtnew)
LLlogmoyalGA3 <- function(y, pars, Xsigma, Xb) {
sigma <- exp(Xsigma %*% pars[1:dim(Xsigma)[2]])
b <- exp(Xb %*%pars[(dim(Xsigma)[2]+1):(dim(Xsigma)[2] + dim(Xb)[2])])
a <- exp(pars[dim(Xsigma)[2] + dim(Xb)[2]+1])
ll <- -0.5*log(2*pi) - log(sigma) + a*log(b) + lgamma(a + 0.5) - lgamma(a) - (1/(2*sigma)+1)*log(y) - (a + 0.5)*log(0.5*(1/y)^(1/sigma) + b)
loglike <- -sum(ll)
return(loglike)
}
mlogmoyalGA3 <- optim(fn = LLlogmoyalGA3, Xsigma = Xsigma,
Xb = Xb,
y = y, hessian = T,
control = list(maxit = 50000),
#method = 'Nelder-Mead',
#par = c(-1,-0.1,0.5,-2,-1))
par = c(-1,-1,-1))
# modout(mlogmoyalGA3)
#
pars <- mlogmoyalGA3$par
sigma <- exp(Xsigma %*% pars[1:dim(Xsigma)[2]])
b <- exp(Xb %*%pars[(dim(Xsigma)[2]+1):(dim(Xsigma)[2] + dim(Xb)[2])])
a <- exp(pars[dim(Xsigma)[2] + dim(Xb)[2]+1])
ufit <- c()
for(i in 1:length(y)){
ufit[i] <- pGLMGA(y[i], sigma = sigma[i], a = a, b = b[i])
}
resLMGA3 <- qnorm(ufit)
u1 <- ufit
f1 <- c()
for(i in 1:length(y)){
f1[i] <- dGLMGA(y[i], sigma = sigma[i], a = a, b = b[i])
}
f1
## ----message=TRUE, warning=FALSE------------------------
library(gamlss)
install.packages("gamlss")
## ----message=TRUE, warning=FALSE------------------------
library(gamlss)
umin <- 20
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'NBI')
dt2 <- dtnew[y2 <= umin]
m.NB <- gamlss(y2 ~ 1, family = NBItr, data = dt2, method = mixed(2, 10000))
summary(m.NB)
pars <- c(coef(m.NB, what = 'mu'), coef(m.NB, what = 'sigma'))
install.packages("gamlss.tr")
## ----message=TRUE, warning=FALSE------------------------
library(gamlss)
library(gamlss.tr)
umin <- 20
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'NBI')
dt2 <- dtnew[y2 <= umin]
m.NB <- gamlss(y2 ~ 1, family = NBItr, data = dt2, method = mixed(2, 10000))
summary(m.NB)
pars <- c(coef(m.NB, what = 'mu'), coef(m.NB, what = 'sigma'))
summary1 <- summary(m.NB)
summary(m.NB)
logLik(m.NB)
mu.NB <- exp(coef(m.NB))
sigma.NB <- exp(coefficients(m.NB, what = 'sigma'))
par(mfrow = c(1, 2), tcl = 0.3, mgp = c(1.5,0,0))
res.death <- residuals(m.NB, what = 'z-scores')
qqnorm(res.death, ylim = c(-3,3), xlim = c(-3,3), main = '')
abline(0,1, col = 'red')
# death > umin
X1 <- model.matrix( ~ 1, data = dtnew[y2>umin])
X2 <- model.matrix( ~ 1,  data = dtnew[y2>umin])
y2new <- dtnew[y2>umin]$y2
GPD.MLE <- fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
GPD.MLE
# plot(GPD.MLE)
GPD.par <- GPD.MLE$results$par
pars <- GPD.MLE$results$par
GPD.hessian <- GPD.MLE$results$hessian
GPD.se <- sqrt(diag(solve(GPD.hessian)))
GPD.Z = GPD.par/GPD.se                                            ##  Z统计???
GPD.p = ifelse(GPD.Z>=0, pnorm(GPD.Z, lower=F)*2, pnorm(GPD.Z)*2)    ## p???
cbind(GPD.par, GPD.se, GPD.p)
scale <- (X1%*%pars[1:dim(X1)[2]])
shape <- X2%*%pars[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]
ufit <- 0
for(i in 1:length(y2new)){
ufit[i] <- evd::pgpd(y2new[i], loc = umin, scale = scale[i], shape = shape[i])
}
resGPD.death <- qnorm(ufit)
qqnorm(resGPD.death, ylim = c(-3, 3), xlim = c(-3, 3),
main = '')
abline(0, 1, col = 'red')
# ======================================================================================
# GPD and negative binom
y <- dtnew$y2
X0 <- model.matrix(~ 1, data = dtnew)
resGPD.death
evd
install.packages("evd")
library(evd)
umin <- 20
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'NBI')
dt2 <- dtnew[y2 <= umin]
m.NB <- gamlss(y2 ~ 1, family = NBItr, data = dt2, method = mixed(2, 10000))
summary(m.NB)
pars <- c(coef(m.NB, what = 'mu'), coef(m.NB, what = 'sigma'))
summary1 <- summary(m.NB)
summary(m.NB)
logLik(m.NB)
mu.NB <- exp(coef(m.NB))
sigma.NB <- exp(coefficients(m.NB, what = 'sigma'))
par(mfrow = c(1, 2), tcl = 0.3, mgp = c(1.5,0,0))
res.death <- residuals(m.NB, what = 'z-scores')
qqnorm(res.death, ylim = c(-3,3), xlim = c(-3,3), main = '')
abline(0,1, col = 'red')
# death > umin
X1 <- model.matrix( ~ 1, data = dtnew[y2>umin])
X2 <- model.matrix( ~ 1,  data = dtnew[y2>umin])
y2new <- dtnew[y2>umin]$y2
GPD.MLE <- fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
GPD.MLE
# plot(GPD.MLE)
GPD.par <- GPD.MLE$results$par
pars <- GPD.MLE$results$par
GPD.hessian <- GPD.MLE$results$hessian
GPD.se <- sqrt(diag(solve(GPD.hessian)))
GPD.Z = GPD.par/GPD.se                                            ##  Z统计???
GPD.p = ifelse(GPD.Z>=0, pnorm(GPD.Z, lower=F)*2, pnorm(GPD.Z)*2)    ## p???
cbind(GPD.par, GPD.se, GPD.p)
scale <- (X1%*%pars[1:dim(X1)[2]])
shape <- X2%*%pars[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]
ufit <- 0
for(i in 1:length(y2new)){
ufit[i] <- evd::pgpd(y2new[i], loc = umin, scale = scale[i], shape = shape[i])
}
resGPD.death <- qnorm(ufit)
qqnorm(resGPD.death, ylim = c(-3, 3), xlim = c(-3, 3),
main = '')
abline(0, 1, col = 'red')
# ======================================================================================
# GPD and negative binom
y <- dtnew$y2
dtnew
y2new
y2new <- dtnew[y2>umin]$y2
GPD.MLE <- fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
??fevd
install.packages("extRemes")
GPD.MLE <- extRemes::fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
GPD.MLE
# plot(GPD.MLE)
GPD.par <- GPD.MLE$results$par
pars <- GPD.MLE$results$par
GPD.hessian <- GPD.MLE$results$hessian
GPD.se <- sqrt(diag(solve(GPD.hessian)))
GPD.Z = GPD.par/GPD.se                                            ##  Z统计???
GPD.p = ifelse(GPD.Z>=0, pnorm(GPD.Z, lower=F)*2, pnorm(GPD.Z)*2)    ## p???
cbind(GPD.par, GPD.se, GPD.p)
# plot(GPD.MLE)
GPD.par <- GPD.MLE$results$par
pars <- GPD.MLE$results$par
scale <- (X1%*%pars[1:dim(X1)[2]])
shape <- X2%*%pars[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]
ufit <- 0
for(i in 1:length(y2new)){
ufit[i] <- evd::pgpd(y2new[i], loc = umin, scale = scale[i], shape = shape[i])
}
resGPD.death <- qnorm(ufit)
qqnorm(resGPD.death, ylim = c(-3, 3), xlim = c(-3, 3),
main = '')
abline(0, 1, col = 'red')
## ----echo=TRUE, message=FALSE, warning=FALSE------------
library(gamlss)
library(gamlss.tr)
library(extRemes)
library(pracma)
library(VineCopula)
library(data.table)#
library(actuar)
library(evd)
library(fCopulae)
library(ggplot2)
# source('0. definition of MGLMGA copula.r')
# source('0. definition of brivariate copula.r')
newtheme <-   theme_bw() + theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
axis.ticks.length = unit(-0.1, "cm"),
plot.title = element_text(hjust = 0.5),
legend.direction = 'vertical',
legend.position = c(.95, .99),
legend.justification = c("right", "top"),
legend.box.just = "right",
legend.text = element_text(size = 10))
## ----message=TRUE, warning=FALSE------------------------
dtnew <- fread('dtnew_copula.csv')
dtnew$ynew <- NULL
dtnew <- dtnew[year %in% seq(1990, 2015)]
dtadjust <- fread('dtcpi.csv', header = T)
dtadjust <- dtadjust[year %in% seq(1990, 2015)]
dtadjust
dtadjust[, CPI_factor := 1/(CPI/615.2)]
setkey(dtadjust, year)
setkey(dtnew, year)
dt <- merge(dtnew, dtadjust)
dt[is.na(y)]$y <- median(dt$y, na.rm = T)
dt[, ynew := y*CPI_factor]
dtnew <- dt[,.(year,
yraw = y,
#location = ,
y1 = ynew, magnitude, death, inj,intensity,
log.area, log.population,
y2 = death + inj)]
dtnew
# dtnew[is.na(log.area)]$log.area <- mean(dt$log.area, na.rm = T)
# dtnew[is.na(log.population)]$log.population <- mean(dt$log.population, na.rm = T)
# dtnew[is.na(intensity)]$intensity <- median(dt$intensity, na.rm = T)
# dtnew[order(y1)]
# tail(dtnew[order(yraw)])
# dtnew <- dtnew[y2>0]
# # =============================================================================
# # difine the hessian matrix output and the stardard error -------------------------------------------------
# modout <- function(m) {
#   Hessian <- m$hessian
#   se <- sqrt(diag(solve(Hessian)))                  ## 标准???
#   Z <- m$par/se                                             ##  Z统计???
#   p <- ifelse(Z>=0, pnorm(Z, lower=F)*2, pnorm(Z)*2)           ## p???
#   summarytable <- round(data.frame(m$par, se, Z, p), 3)
#   NLL <- m$value  # - loglikelihood value
#   AIC <- 2*length(m$par) + 2*NLL
#   BIC <- log((nrow(dtnew)))*length(m$par) + 2*NLL
#   list(summary = summarytable, ll =  - m$value, AIC = AIC, BIC = BIC)
# }
y <- dtnew$y1
modout <- function(m) {
Hessian <- m$hessian
se <- sqrt(diag(solve(Hessian)))                  ## stardard error
Z <- m$par/se                                             ##  Z statistic
p <- ifelse(Z>=0, pnorm(Z, lower=F)*2, pnorm(Z)*2)           ## p value
summarytable <- round(data.frame(m$par, se, Z, p), 3)
NLL <- m$value  # - loglikelihood value
AIC <- 2*length(m$par) + 2*NLL
BIC <- log(length(y))*length(m$par) + 2*NLL
list(summary = summarytable, ll =  - m$value, AIC = AIC, BIC = BIC)
}
# # define a new function
# remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)] # 去除 NA ?????? ??? 无限???
## ----message=TRUE, warning=FALSE------------------------
# -------------------------------------------------------------
# GLMGA III distribution
# -------------------------------------------------------------
y <- dtnew$y1
# Xsigma <- model.matrix(~ magnitude, data = dtnew);
# Xb <- model.matrix(~ intensity, data = dtnew)
Xsigma <- model.matrix(~ 1, data = dtnew);
Xb <- model.matrix(~ 1, data = dtnew)
LLlogmoyalGA3 <- function(y, pars, Xsigma, Xb) {
sigma <- exp(Xsigma %*% pars[1:dim(Xsigma)[2]])
b <- exp(Xb %*%pars[(dim(Xsigma)[2]+1):(dim(Xsigma)[2] + dim(Xb)[2])])
a <- exp(pars[dim(Xsigma)[2] + dim(Xb)[2]+1])
ll <- -0.5*log(2*pi) - log(sigma) + a*log(b) + lgamma(a + 0.5) - lgamma(a) - (1/(2*sigma)+1)*log(y) - (a + 0.5)*log(0.5*(1/y)^(1/sigma) + b)
loglike <- -sum(ll)
return(loglike)
}
mlogmoyalGA3 <- optim(fn = LLlogmoyalGA3, Xsigma = Xsigma,
Xb = Xb,
y = y, hessian = T,
control = list(maxit = 50000),
#method = 'Nelder-Mead',
#par = c(-1,-0.1,0.5,-2,-1))
par = c(-1,-1,-1))
modout(mlogmoyalGA3)
#
pars <- mlogmoyalGA3$par
sigma <- exp(Xsigma %*% pars[1:dim(Xsigma)[2]])
b <- exp(Xb %*%pars[(dim(Xsigma)[2]+1):(dim(Xsigma)[2] + dim(Xb)[2])])
a <- exp(pars[dim(Xsigma)[2] + dim(Xb)[2]+1])
ufit <- c()
for(i in 1:length(y)){
ufit[i] <- pLMGA(y[i], sigma = sigma[i], a = a, b = b[i])
}
resLMGA3 <- qnorm(ufit)
modout(mlogmoyalGA3)
u1 <- ufit
f1 <- c()
for(i in 1:length(y)){
f1[i] <- dLMGA(y[i], sigma = sigma[i], a = a, b = b[i])
}
#X <- model.matrix(~ magnitude + intensity, data = dtnew)
#
# X <- model.matrix(~ 1, data = dtnew)
# LLpareto <- function(pars, y, X){
#   lengthpar <- dim(X)[2]
#   beta <- exp(pars[lengthpar+1])
#   sigma <- exp(X%*%pars[1:lengthpar])
#   logL <- log(beta) + beta*log(sigma) - (beta+1)*log(y+sigma) # log-likelihood
#   ll <- -sum(logL)
#   return(ll)
# }
# mlpareto <- optim(fn = LLpareto,
#                   y = y, X = X,
#                   par = rep(times = (dim(X)[2]+1), x = 0.1), hessian = T)
# modout(mlpareto)
# pars <- mlpareto$par
# lengthpar <- dim(X)[2]
# beta <- exp(pars[lengthpar+1])
# sigma <- exp(X%*%pars[1:lengthpar])
# #u1 <- ufit
# f1 <- ufit <- c()
# for(i in 1:length(y)){
#   f1[i] <- dpareto2(y[i], shape = beta, scale = sigma[i])
#   ufit[i] <- ppareto2(y[i], shape = beta, scale = sigma[i])
# }
# respareto <- qnorm(ufit)
# u1 <- ufit
## ----message=TRUE, warning=FALSE------------------------
umin <- 20
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'NBI')
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'PO')
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'ZINBI')
gen.trun(par = umin + 1, type = 'right', name = 'tr', family = 'ZIP')
dt2 <- dtnew[y2 <= umin]
m.NB <- gamlss(y2 ~ 1, family = NBItr, data = dt2, method = mixed(2, 10000))
summary(m.NB)
pars <- c(coef(m.NB, what = 'mu'), coef(m.NB, what = 'sigma'))
summary1 <- summary(m.NB)
summary(m.NB)
logLik(m.NB)
mu.NB <- exp(coef(m.NB))
sigma.NB <- exp(coefficients(m.NB, what = 'sigma'))
par(mfrow = c(1, 2), tcl = 0.3, mgp = c(1.5,0,0))
res.death <- residuals(m.NB, what = 'z-scores')
qqnorm(res.death, ylim = c(-3,3), xlim = c(-3,3), main = '')
abline(0,1, col = 'red')
# death > umin
X1 <- model.matrix( ~ 1, data = dtnew[y2>umin])
X2 <- model.matrix( ~ 1,  data = dtnew[y2>umin])
y2new <- dtnew[y2>umin]$y2
GPD.MLE <- fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
GPD.MLE
# plot(GPD.MLE)
GPD.par <- GPD.MLE$results$par
pars <- GPD.MLE$results$par
GPD.hessian <- GPD.MLE$results$hessian
GPD.se <- sqrt(diag(solve(GPD.hessian)))
GPD.Z = GPD.par/GPD.se                                            ##  Z统计???
GPD.p = ifelse(GPD.Z>=0, pnorm(GPD.Z, lower=F)*2, pnorm(GPD.Z)*2)    ## p???
cbind(GPD.par, GPD.se, GPD.p)
scale <- (X1%*%pars[1:dim(X1)[2]])
shape <- X2%*%pars[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]
ufit <- 0
for(i in 1:length(y2new)){
ufit[i] <- evd::pgpd(y2new[i], loc = umin, scale = scale[i], shape = shape[i])
}
resGPD.death <- qnorm(ufit)
qqnorm(resGPD.death, ylim = c(-3, 3), xlim = c(-3, 3),
main = '')
abline(0, 1, col = 'red')
# ======================================================================================
# GPD and negative binom
y <- dtnew$y2
X0 <- model.matrix(~ 1, data = dtnew)
X1 <- model.matrix( ~ 1, data = dtnew) # GP
X2 <- model.matrix( ~ 1, data = dtnew) # GP
par1 <- GPD.MLE$results$par
par2 <-  c(coef(m.NB, what = 'mu'), coef(m.NB, what = 'sigma'))
p1 <- nrow(dt2)/nrow(dtnew)
scale <- X1%*%par1[1:dim(X1)[2]]
shape <- X2%*%par1[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]
dtu2 <- data.table(mu = as.vector(exp(X0%*%par2[1:dim(X0)[2]])),
sigma = exp(par2[length(par2)]),
scale = as.vector(X1%*%par1[1:dim(X1)[2]]),
shape = as.vector(X2%*%par1[c((dim(X1)[2]+1):(dim(X1)[2] + dim(X2)[2]))]),
y = y, y_ = y - 1,
y__ = y - 2)
dtu2[y_<0]$y_ <- 0
dtu2[y__<0]$y__ <- 0
dtu2
u <- with(dtu2, {
u2 <- u2_ <- u2__ <- u0 <- 0
for(i in 1:length(y)){
if(y[i] <= umin){ u2[i] <- p1*as.vector(pNBItr(y[i], mu = mu[i], sigma = sigma[i]))}
else{ u2[i] <- p1 + (1-p1)*evd::pgpd(y[i], loc = umin, scale = scale[i], shape = shape[i])}
if(y_[i] <= umin){ u2_[i] <- p1*as.vector(pNBItr(y_[i], mu = mu[i], sigma = sigma[i]))}
else{ u2_[i] <- p1 + (1-p1)*evd::pgpd(y_[i], loc = umin, scale = scale[i], shape = shape[i])}
if(y__[i] <= umin){ u2__[i] <- p1*as.vector(pNBItr(y__[i], mu = mu[i], sigma = sigma[i]))}
else{ u2__[i] <- p1 + (1-p1)*evd::pgpd(y__[i], loc = umin, scale = scale[i], shape = shape[i])}
u0 <- pNBItr(umin, mu = mu[i], sigma = sigma[i])
}
u <- cbind(u2, u2_, u2__, u0)
u
})
u2 <- u[,1]
u2_ <- u[,2]
u2__ <- u[,3]
u2_[which(dtnew$y2 - 1 < 0)] <- 0
u2__[which(dtnew$y2 - 2 < 0)] <- 0
dtu2$u2 <- u2
dtu2$u2_ <- u2_
dtu2$u2__ <- u2__
dtu2
# =========================================================================================
# density of y2 --------------------------------------------------------------------------
dtu2$f2 <- with(dtu2, {
f <- 0
for(i in 1:length(y)){
if(y[i] <= umin){
f[i] <- p1*as.vector(dNBItr(y[i], mu = mu[i], sigma = sigma[i]))}
else{
f[i] <- (1-p1)*evd::dgpd(y[i], loc = umin, scale = scale[i], shape = shape[i])}
}
f
})
f2 <- dtu2$f2
## ----message=TRUE, warning=FALSE------------------------
head(cbind(u1,u2))
head(cbind(f1,f2))
head(u2_)
y2
dt2
?fevd
umin
dtnew
GPD.MLE <- extRemes::fevd(x = y2,
scale.fun = ~ 1,
shape.fun = ~ 1,
threshold = umin, method = 'MLE', use.phi = F,
type = "GP", data = dtnew)
GPD.MLE
