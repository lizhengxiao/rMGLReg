# =======================================================================
# Case 8:
# sigma <- c(0.5, 0.5)
# a <- 1
# b <- c(1, 5)
# =======================================================================
n.grid <- 100
sigma <- c(0.5, 0.5)
a <- 1
b <- c(1, 5)
xgrid <- ygrid <- seq(0.01, 8, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d[,1] <- grid[,1]
mtrx3d[,2] <- grid[,2]
for(i in 1:nrow(mtrx3d)){
mtrx3d[i,3] = dMGLMGA(y1 = grid[i,1], y2 = grid[i,2],
sigma = sigma,
a = a, b = b)
}
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
bins <- 10
sigma1 <- sigma[1]; sigma2 <- sigma[2]
b1 <- b[1]; b2 <- b[2]
Nsim <- 1000
u1sim <- runif(Nsim, min = 0, max = 1)
y1sim <- qGLMGA(u1sim, sigma = sigma1, a = a, b = b1)
anew <- a + 0.5; b2new <- b2*(1 + y1sim^(-1/sigma1)/(2*b1))
y2sim <- NA
for(i in 1:Nsim){
y2sim[i] <- rGLMGA(1, sigma = sigma2, a = anew, b = b2new[i])
}
ysim <- data.table(y1 = y1sim, y2 = y2sim)
v8 <- ggplot() +
scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +
theme_bw() +
ggtitle(TeX(paste(sprintf('$\\sigma_1 = %g$', sigma[1]),
',',
sprintf('$\\sigma_2 = %g$', sigma[2]),',',
sprintf('$\\a = %g$', a),',',
sprintf('$\\b_1 = %g$', b[1]),',',
sprintf('$\\b_2 = %g$', b[2])))
) +
theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
panel.grid.minor = element_blank(),
plot.title = element_text(hjust = 0.5)) +
labs(x = TeX("$y_1$"), y = TeX("$y_2$"))  +
geom_contour(data = mtrx3d,
aes(x = u1, y = u2, z = cu1u2),
bins = bins,
colour = 'black', weight = 3) +
geom_point(data = ysim, aes(x = y1, y = y2),
#shape = 1,
size = 0.5,
color = 'red')
# =======================================================================
# Case VI:
# sigma <- c(0.5, 0.5)
# a <- 1
# b <- c(5, 5)
# =======================================================================
n.grid <- 100
sigma <- c(2, 0.5)
a <- 1
b <- c(5, 5)
xgrid <- ygrid <- seq(0.01, 8, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d[,1] <- grid[,1]
mtrx3d[,2] <- grid[,2]
for(i in 1:nrow(mtrx3d)){
mtrx3d[i,3] = dMGLMGA(y1 = grid[i,1], y2 = grid[i,2],
sigma = sigma,
a = a, b = b)
}
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
bins <- 10
sigma1 <- sigma[1]; sigma2 <- sigma[2]
b1 <- b[1]; b2 <- b[2]
Nsim <- 1000
u1sim <- runif(Nsim, min = 0, max = 1)
y1sim <- qGLMGA(u1sim, sigma = sigma1, a = a, b = b1)
anew <- a + 0.5; b2new <- b2*(1 + y1sim^(-1/sigma1)/(2*b1))
y2sim <- NA
for(i in 1:Nsim){
y2sim[i] <- rGLMGA(1, sigma = sigma2, a = anew, b = b2new[i])
}
ysim <- data.table(y1 = y1sim, y2 = y2sim)
v9 <- ggplot() +
scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +
theme_bw() +
ggtitle(TeX(paste(sprintf('$\\sigma_1 = %g$', sigma[1]),
',',
sprintf('$\\sigma_2 = %g$', sigma[2]),',',
sprintf('$\\a = %g$', a),',',
sprintf('$\\b_1 = %g$', b[1]),',',
sprintf('$\\b_2 = %g$', b[2])))
) +
theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
panel.grid.minor = element_blank(),
plot.title = element_text(hjust = 0.5)) +
labs(x = TeX("$y_1$"), y = TeX("$y_2$"))  +
geom_contour(data = mtrx3d,
aes(x = u1, y = u2, z = cu1u2),
bins = bins,
colour = 'black', weight = 3) +
geom_point(data = ysim, aes(x = y1, y = y2),
#shape = 1,
size = 0.5,
color = 'red')
library(patchwork)
p1 <- v1 + v2 + v3 + plot_layout(ncol = 3)
p2 <- v4 + v5 + v6 + plot_layout(ncol = 3)
p3 <- v7 + v8 + v9 + plot_layout(ncol = 3)
p1
p2
p3
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(rMGLReg)
library(data.table)
dtnew <- data.table(earthqCHI)
y <- dtnew$y1
Xsigma <- model.matrix(~1, data = dtnew)
Xb <- model.matrix(~1, data = dtnew)
LLlogmoyalGA3 <- function(y, pars, Xsigma, Xb) {
sigma <- exp(Xsigma %*% pars[1:dim(Xsigma)[2]])
b <- exp(Xb %*% pars[(dim(Xsigma)[2] + 1):(dim(Xsigma)[2] + dim(Xb)[2])])
a <- exp(pars[dim(Xsigma)[2] + dim(Xb)[2] + 1])
ll <- -0.5 * log(2 * pi) - log(sigma) + a * log(b) + lgamma(a + 0.5) - lgamma(a) - (1 / (2 * sigma) + 1) * log(y) - (a + 0.5) * log(0.5 * (1 / y)^(1 / sigma) + b)
loglike <- -sum(ll)
return(loglike)
}
mlogmoyalGA3 <- optim(
fn = LLlogmoyalGA3, Xsigma = Xsigma,
Xb = Xb,
y = y, hessian = T,
control = list(maxit = 50000),
par = c(-1, -1, -1)
)
pars <- mlogmoyalGA3$par
sigma <- exp(Xsigma %*% pars[1:dim(Xsigma)[2]])
b <- exp(Xb %*% pars[(dim(Xsigma)[2] + 1):(dim(Xsigma)[2] + dim(Xb)[2])])
a <- exp(pars[dim(Xsigma)[2] + dim(Xb)[2] + 1])
ufit <- c()
for (i in 1:length(y)) {
ufit[i] <- pGLMGA(y[i], sigma = sigma[i], a = a, b = b[i])
}
resLMGA3 <- qnorm(ufit)
u1 <- ufit
f1 <- c()
for (i in 1:length(y)) {
f1[i] <- dGLMGA(y[i], sigma = sigma[i], a = a, b = b[i])
}
head(cbind(dtnew$u1, dtnew$u2))
head(cbind(dtnew$u1, dtnew$u2_))
head(cbind(dtnew$f1, dtnew$f2))
MGL.mle.mixed
library(rMGLReg)
u <- cbind(earthqCHI$u1, earthqCHI$u2)
u_ <- cbind(earthqCHI$u1, earthqCHI$u2_)
y <- cbind(earthqCHI$y1, earthqCHI$y2)
f <- cbind(earthqCHI$f1, earthqCHI$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
m.norm <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Normal", method = "L-BFGS-B",
initpar = 0.2)
m.t <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "t", method = "L-BFGS-B",earthqCHI
initpar = c(0.1,3))
library(rMGLReg)
u <- cbind(earthqCHI$u1, earthqCHI$u2)
u_ <- cbind(earthqCHI$u1, earthqCHI$u2_)
y <- cbind(earthqCHI$y1, earthqCHI$y2)
f <- cbind(earthqCHI$f1, earthqCHI$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
m.norm <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Normal", method = "L-BFGS-B",
initpar = 0.2)
m.t <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "t", method = "L-BFGS-B",
initpar = c(0.1,3))
m.gumbel <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Gumbel",  method = "L-BFGS-B",
initpar = c(2))
m.MGLMGA180 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGL180",  method = "L-BFGS-B",
initpar = c(2))
m.MGB2 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGB2",  method = "L-BFGS-B",
initpar = c(1, 4, 0.4))
m.MGLEV180 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGL-EV180",  method = "L-BFGS-B",
initpar = c(0.2))
library(rMGLReg)
u <- cbind(earthqCHI$u1, earthqCHI$u2)
u_ <- cbind(earthqCHI$u1, earthqCHI$u2_)
y <- cbind(earthqCHI$y1, earthqCHI$y2)
f <- cbind(earthqCHI$f1, earthqCHI$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
head(U)
head(U_)
head(f)
hcMGL.bivar
library(rMGLReg)
m.MGL180$se
library(rMGLReg)
u <- cbind(earthqCHI$u1, earthqCHI$u2)
u_ <- cbind(earthqCHI$u1, earthqCHI$u2_)
y <- cbind(earthqCHI$y1, earthqCHI$y2)
f <- cbind(earthqCHI$f1, earthqCHI$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
library(splines)
X <- ns(earthqCHI$year, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
m.MGL180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(0.64, 1.2, 1, -0.2))
m.MGLEV180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL-EV180",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(-0.32, 1, 1, 1))
m.gumbel <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "Gumbel",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(-0.32, 1, 1, 1))
m.MGL180
m.MGL180$se
sd.copula
estimates.copula <- rbind((m.MGL180$estimates), (m.MGLEV180$estimates), (m.gumbel$estimates))
sd.copula <- rbind((m.MGL180$se), (m.MGLEV180$se), (m.gumbel$se))
ll.copula <- rbind((m.MGL180)$loglike, (m.MGLEV180)$loglike, (m.gumbel)$loglike)
AIC.copula <- rbind((m.MGL180)$AIC, (m.MGLEV180)$AIC, (m.gumbel)$AIC)
BIC.copula <- rbind((m.MGL180)$BIC, (m.MGLEV180)$BIC, (m.gumbel)$BIC)
table1 <- cbind(estimates.copula, sd.copula, ll.copula, AIC.copula, BIC.copula)
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "estimates", "se", "se", "se","se",'loglike', 'AIC', 'BIC')
knitr::kable(t(table1), digits = 3)
library(rMGLReg)
u <- cbind(earthqCHI$u1, earthqCHI$u2)
u_ <- cbind(earthqCHI$u1, earthqCHI$u2_)
y <- cbind(earthqCHI$y1, earthqCHI$y2)
f <- cbind(earthqCHI$f1, earthqCHI$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
library(splines)
X <- ns(earthqCHI$year, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
m.MGL180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(0.64, 1.2, 1, -0.2))
m.MGLEV180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL-EV180",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(-0.32, 1, 1, 1))
m.gumbel <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "Gumbel",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(-0.32, 1, 1, 1))
estimates.copula <- rbind((m.MGL180$estimates), (m.MGLEV180$estimates), (m.gumbel$estimates))
sd.copula <- rbind((m.MGL180$se), (m.MGLEV180$se), (m.gumbel$se))
ll.copula <- rbind((m.MGL180)$loglike, (m.MGLEV180)$loglike, (m.gumbel)$loglike)
AIC.copula <- rbind((m.MGL180)$AIC, (m.MGLEV180)$AIC, (m.gumbel)$AIC)
BIC.copula <- rbind((m.MGL180)$BIC, (m.MGLEV180)$BIC, (m.gumbel)$BIC)
table1 <- cbind(estimates.copula, sd.copula, ll.copula, AIC.copula, BIC.copula)
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "estimates", "se", "se", "se","se",'loglike', 'AIC', 'BIC')
knitr::kable(t(table1), digits = 3)
library(MASS)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Survival MGL')
lines(delta.est, col = 'red', lwd = 2)
# Surivial MGL-EV regression
par.est <- m.MGLEV180$estimates
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGLEV180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Survival MGL-EV')
lines(delta.est, col = 'red', lwd = 2)
# Gumbel regression
par.est <- m.gumbel$estimates
delta.est <- exp(Xcopula%*%par.est) + 1
cov.est <- -solve(m.gumbel$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,]) + 1
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Gumbel')
lines(delta.est, col = 'red', lwd = 2)
FALSE
library(rMGLReg)
pkgdown::build_site()
pkgdown::build_site()
devtools::check()
devtools::check()
ï¼Ÿsrc
?src
usethis::use_pkgdown()
pkgdown::build_site()
usethis::use_tidy_github_actions()
devtools::build_rmd()
library(rMGLReg)
library(rMGLReg)
install.packages("rMGLReg")
library(rMGLReg)
renv::status()
install.packages("rmarkdown")
library(rMGLReg)
renv::restore()
library(rMGLReg)
rcMGL.multi
?rcMGL.multi
library(rMGLReg)
library(devtools)
#' @name GLMGA
#' @rdname  GLMGA
#' @title The GLMGA distribution
#'
#' @param y vector of quantiles.
#' @param u vector of probabilities.
#' @param sigma parameter of GLMGA distribution.
#' @param a parameter of GLMGA distribution.
#' @param b parameter of GLMGA distribution.
#' @param log logical; if TRUE, probabilities/densities p are returned as log(p).
#' @param n number of observations. If length(n) > 1, the length is taken to be the number required.
#' @importFrom stats runif
#' @importFrom stats pbeta
#' @description Density (\code{dGLMGA}), distribution function (\code{pGLMGA}), quantile function (\code{qGLMGA}) and random generation (\code{rGLMGA}) for the GLMGA distribution with parameters sigma, a and b.
#' @references Zhengxiao Li, Jan Beirlant, Shengwang Meng. Generalizing The Log-Moyal Distribution And Regression Models For Heavy-Tailed Loss Data. ASTIN Bulletin: The Journal of the IAA, 11(1):57-99, 2021.
#' @details
#' The GLMGA distribution with parameters (sigma, a, b) has density
#' \deqn{f(y)=\frac{(2b)^a}{\sigma B(a,\frac{1}{2})}\frac{y^{-(\frac{1}{2\sigma}+1)}}{(y^{-\frac{1}{\sigma}}+2b)^{a + \frac{1}{2}}},}
#' for \eqn{y>0,\sigma>0, a>0, b>0}.
#'
#' The cumulative distribution function \eqn{F(y)} is
#'
#' \deqn{F(y)=1-I_{\frac{1}{2},a}(\frac{y^{-1/\sigma}}{y^{-1/\sigma}+2b}).}
#'
#' Here \eqn{I_{m,n}()} is the beta cumulative distribution function (or regularized incomplete beta function) with parameters shape1 = m and shape2 = n
#' implemented by R's \code{\link[stats]{pbeta}} and defined in its help.
#'
#' The quantile function \eqn{F^{-1}(u)} is
#'
#' \deqn{(2b)^{-\sigma}[\frac{I^{-1}_{\frac{1}{2},a}(1-p)}{1-I^{-1}_{\frac{1}{2},a}(1-p)}]^{-\sigma},}
#' where \eqn{u \in (0,1)}, and \eqn{I_{m,n}^{-1}()} denotes the inverse of the beta cumulative distribution function (or regularized incomplete beta function)
#' with parameters shape1 = m and shape2 = n
#' implemented by R's \code{\link[stats]{qbeta}}.
#'
#'
#'
#' @return
#' \code{dGLMGA} gives the density, \code{pGLMGA} gives the distribution function, \code{qGLMGA} gives the quantile function, and \code{rGLMGA} generates random deviates.
#'
#' Invalid arguments will result in return value NaN, with a warning.
#'
#' The length of the result is determined by n for rgamma, and is the maximum of the lengths of the numerical arguments for the other functions.
#'
#' The numerical arguments other than n are recycled to the length of the result. Only the first elements of the logical arguments are used.
#'
#'
NULL
#' @rdname  GLMGA
#' @export
#' @examples
#' # density function at value 0.5 and 0.1
#' dGLMGA(c(0.5, 0.1), sigma = 2, a = 2, b = 3, log = FALSE)
dGLMGA <- function(y, sigma, a, b, log = FALSE) {
if (log == FALSE) {
exp(-0.5 * log(2 * pi) - log(sigma) + a * log(b) + lgamma(a + 0.5) - lgamma(a) - (1 / (2 * sigma) + 1) * log(y) - (a + 0.5) * log(0.5 * (1 / y)^(1 / sigma) + b))
} else if (log == TRUE) {
-0.5 * log(2 * pi) - log(sigma) + a * log(b) + lgamma(a + 0.5) - lgamma(a) - (1 / (2 * sigma) + 1) * log(y) - (a + 0.5) * log(0.5 * (1 / y)^(1 / sigma) + b)
}
}
#' @rdname GLMGA
#' @export
#'
#' @examples
#' # cdf at value 10 and 20.
#' pGLMGA(c(10, 20), sigma = 2, a = 2, b = 3)
pGLMGA <- function(y, sigma, a, b) {
z <- y^(-1 / sigma) / (y^(-1 / sigma) + 2 * b)
p <- 1 - pbeta(z, shape1 = 0.5, shape2 = a)
p
}
#' @rdname GLMGA
#' @export
#'
#' @examples
#' # quantile function at level 50% and 10%
#' qGLMGA(c(0.5, 0.1), sigma = 2, a = 2, b = 3)
qGLMGA <- function(u, sigma, a, b) {
c <- (2 * b)^(-sigma)
# I <- pbeta(u, shape1 = 0.5, shape2 = a)
Iinv <- qbeta(1 - u, shape1 = 0.5, shape2 = a)
c * (Iinv / (1 - Iinv))^(-sigma)
}
#' @rdname GLMGA
#' @export
#' @examples
#' # simulate 10 samples from GLMGA distribution with parameters (2, 2, 3)
#' rGLMGA(n = 10, sigma = 2, a = 2, b = 3)
rGLMGA <- function(n, sigma, a, b) {
u <- runif(n, min = 0, max = 1)
qGLMGA <- Vectorize(qGLMGA)
r <- qGLMGA(u, sigma = sigma, a = a, b = b)
r
}
#' #' Sum of vector elements
#' #'
#' #' \code{sum} returns the sum of all the values present in its arguments.
#' #'
#' #' This is a generic function: methods can be defined for it directly
#' #' or via the \code{\link{Summary}} group generic. For this to work properly,
#' #' the arguments \code{...} should be unnamed, and dispatch is on the
#' #' first argument.
#' #'
#' #' @param ... Numeric, complex, or logical vectors.
#' #' @param na.rm A logical scalar. Should missing values (including NaN)
#' #'   be removed?
#' #' @return If all inputs are integer and logical, then the output
#' #'   will be an integer. If integer overflow
#' #'   \url{https://en.wikipedia.org/wiki/Integer_overflow} occurs, the output
#' #'   will be NA with a warning. Otherwise it will be a length-one numeric or
#' #'   complex vector.
#' #'
#' #'   Zero-length vectors have sum 0 by definition. See
#' #'   \url{https://en.wikipedia.org/wiki/Empty_sum} for more details.
#' #' @examples
#' #' sum(1:10)
#' #' sum(1:5, 6:10)
#' #' sum(F, F, F, T, T)
#' #'
#' #' sum(.Machine$integer.max, 1L)
#' #' sum(.Machine$integer.max, 1)
#' #'
#' #' \dontrun{
#' #' sum("a")
#' #' }
#' sum <- function(..., na.rm = TRUE) {}
?dGLMGA
dGLMGA
library(rMGLReg)
load_all()
load_all()
library(devtools)
load_all()
library(rMGLReg)
set.seed(271)
n <- 1000
delta <- 1.2
d <- 3
U <- rcMGL.multi(n = 1000, d = d, pars = delta)
cor(U, method = "kendall")
library(rMGLReg)
library(rMGLReg)
set.seed(271)
n <- 1000
delta <- 1.2
d <- 3
U <- rcMGL.multi(n = 1000, d = d, pars = delta)
cor(U, method = "kendall")
