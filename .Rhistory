}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Gumbel"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "Gumbel"){
dcop <- dtcop
arg.cop <- argt
}
loglike.copula <- function(U, dcop, arg.cop = list(), initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000 }
return(res)
}}
resopt <- nlm(f = loglike.copula, U = U, p = initpar,
dcop = dcop, arg.cop = arg.cop,
hessian = T)
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(-resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
}
m.norm <- MGL.mle(U = U,
copula  = "Normal",
arg.cop = argnorm,
initpar = 0.5)
MGL.mle
#' Fitting bivariate MGL copula models
#'
#' @description MGL.reg is used to fit bivariate MGL copula regression models.
#' @param U two-dimenstional matrix with values in [0,1].
#' @param X design matrix
#' @param copula 'MGL', 'MGL180', "MGL-EV", "MGL-EV180", "MGB2", "Normal" , "Student-t"
#' @param initpar Initial values for the parameters to be optimized over.
#' @param ... 		additional arguments to be passed to f.
#' @md
#' @return A list containing the following components:
#' * minimum   the value of the estimated minimum of f.
#' * estimate	  the point at which the minimum value of f is obtained.
#' * gradient	the gradient at the estimated minimum of f.
#' * hessian	the hessian at the estimated minimum of f (if requested).
#' @export
#'
#'
#'
MGL.mle <- function(U, copula = c('MGL', 'MGL180', "MGL-EV",
"MGL-EV180",
"Gumbel",
"Normal", "MGB2", "t"
),
initpar, ...){
dnormcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
dtcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "t",
param = param[2]))  # t copula
dgumcop <- function(U, param)
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = 1 - U[,1], u2 = 1 - U[,2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param){
as.numeric(dcMGLEV(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
}
loglike.copula <- function(U, dcop, arg.cop = list(), initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000 }
return(res)
}}
resopt <- nlm(f = loglike.copula, U = U, p = initpar,
dcop = dcop, arg.cop = arg.cop,
hessian = T)
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(-resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
}
m.norm <- MGL.mle(U = U,
copula  = "Normal",
arg.cop = argnorm,
initpar = 0.5)
MGL.mle
U = U
m.norm <- MGL.mle(U = U,
copula  = "Normal",
initpar = 0.5)
U
copula <- "Normal"
#' @md
#' @return A list containing the following components:
#' * minimum   the value of the estimated minimum of f.
#' * estimate	  the point at which the minimum value of f is obtained.
#' * gradient	the gradient at the estimated minimum of f.
#' * hessian	the hessian at the estimated minimum of f (if requested).
#' @export
#'
#'
#'
MGL.mle <- function(U, copula = c('MGL', 'MGL180', "MGL-EV",
"MGL-EV180",
"Gumbel",
"Normal", "MGB2", "t"
),
initpar, ...){
dnormcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
dtcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "t",
param = param[2]))  # t copula
dgumcop <- function(U, param)
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = 1 - U[,1], u2 = 1 - U[,2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param){
as.numeric(dcMGLEV(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
}
loglike.copula <- function(U, dcop, arg.cop = list(), initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000 }
return(res)
}}
resopt <- nlm(f = loglike.copula, U = U, p = initpar,
dcop = dcop, arg.cop = arg.cop,
hessian = T)
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(-resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
}
dnormcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
dtcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "t",
param = param[2]))  # t copula
dgumcop <- function(U, param)
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = 1 - U[,1], u2 = 1 - U[,2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param){
as.numeric(dcMGLEV(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
}
dcop
arg.cop
# loglike.copula <- function(U, dcop, arg.cop = list(), initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000 }
return(res)}
# loglike.copula <- function(U, initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000 }
return(res)}
# }
resopt <- nlm(f = loglike.copula,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = T)
initpar
initpar = 0.5
resopt <- nlm(f = loglike.copula,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = T)
resopt <- nlm(f = copLogL,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = T)
resopt
?nlm
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(-resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
resopt$hessian
(solve(-resopt$hessian)
resopt
resopt <- nlm(f = copLogL,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = T)
resopt
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
#' Fitting bivariate MGL copula models
#'
#' @description MGL.reg is used to fit bivariate MGL copula regression models.
#' @param U two-dimenstional matrix with values in [0,1].
#' @param X design matrix
#' @param copula 'MGL', 'MGL180', "MGL-EV", "MGL-EV180", "MGB2", "Normal" , "Student-t"
#' @param initpar Initial values for the parameters to be optimized over.
#' @param ... 		additional arguments to be passed to f.
#' @md
#' @return A list containing the following components:
#' * minimum   the value of the estimated minimum of f.
#' * estimate	  the point at which the minimum value of f is obtained.
#' * gradient	the gradient at the estimated minimum of f.
#' * hessian	the hessian at the estimated minimum of f (if requested).
#' @export
#'
#'
#'
MGL.mle <- function(U, copula = c('MGL', 'MGL180', "MGL-EV",
"MGL-EV180",
"Gumbel",
"Normal", "MGB2", "t"
),
initpar, ...){
dnormcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
dtcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "t",
param = param[2]))  # t copula
dgumcop <- function(U, param)
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = 1 - U[,1], u2 = 1 - U[,2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param){
as.numeric(dcMGLEV(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
}
# loglike.copula <- function(U, initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000 }
return(res)}
# }
resopt <- nlm(f = copLogL,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = T)
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
}
m.norm <- MGL.mle(U = U,
copula  = "Normal",
initpar = 0.5)
m.t <- MGL.mle(U = U,
copula  = "t",
initpar = c(0.5, 4))
m.t
?MGL.mle
m.norm <- MGL.mle(U = U,
copula  = "Normal",
initpar = 0.5)
m.t <- MGL.mle(U = U,
copula  = "t",
initpar = c(0.5, 4))
m.gumbel <- MGL.mle(U = U,
copula  = "Gumbel",
initpar = c(2))
m.MGLMGA180 <- MGL.mle(U,
copula  = "MGL180",
initpar = c(1))
m.MGLMGA180
m.MGLMGA180 <- MGL.mle(U,
copula  = "MGL180",
initpar = c(1.5))
dcMGL180.bivar
dcMGL.bivar <- function(u1, u2, pars){
dim <- 2
a <- 1/pars
q1 <- qbeta(1-u1, shape1 = 0.5, shape2 = a)/(1 - qbeta(1-u1, shape1 = 0.5, shape2 = a))
q2 <- qbeta(1-u2, shape1 = 0.5, shape2 = a)/(1 - qbeta(1-u2, shape1 = 0.5, shape2 = a))
# if(u1 == 0|u2 == 0|q1 == Inf|q2 == Inf) dc <- 0
if(q1 == Inf|q2 == Inf) {
dc <- 0
} else {
q <- cbind(q1, q2)
#dc <- gamma(a)^(dim - 1)*gamma(a + dim/2)/(gamma(a + 0.5)^dim)*(q1 + 1)^(a + 0.5)*(q2 + 1)^(a + 0.5)/((q1 + q2) + 1)^(a + dim/2)
dc <- gamma(a)^(dim - 1)/(gamma(a + 0.5)^(dim - 1))/(gamma(a + 0.5))*gamma(a + dim/2)*(q1 + 1)^(a + 0.5)*(q2 + 1)^(a + 0.5)/((q1 + q2) + 1)^(a + dim/2)
}
return(dc)
}
dcGLMGA <- Vectorize(dcGLMGA)
dcMGL.bivar <- Vectorize(dcMGL.bivar)
