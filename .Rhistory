<<<<<<< Updated upstream
?dgamma
=======
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
} else if(copula == "MGB2"){
dcop <- dMGB2
arg.cop <- argMGB2
}
# loglike.copula <- function(U, initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000}
return(res)}
# }
resopt <- nlm(f = copLogL,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = T)
# resopt
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
}
#
# m.MGLMGA180 <- MGL.mle(U,
#                        copula  = "MGL180",
#                        initpar = c(0.5))
m.MGLMGA180 <- MGL.mle(U,
copula  = "MGL180",
initpar = c(1))
m.MGLMGA180
recap <- function(x){
res <- c(alpha = x$estimates,
se = x$se,
loglike = x$loglike,
AIC = x$AIC, BIC = x$BIC)
if(length(res) < 6)
res <- c(res[1], NA, NA,res[2], NA, NA, res[3:5])
if (length(res) > 6 & length(res) < 9)
res <- c(res[1:2], NA, res[3:4], NA, res[5:7])
res <- as.matrix(res)
colnames(res) <- x$copula$name
res}
res.all <- round(cbind(recap(m.norm),
recap(m.t),
recap(m.gumbel),
recap(m.MGLMGA180),
recap(m.MGB2),
recap(m.MGLEV180)
), 4)
out.com <- t(res.all)
out.com[order(out.com[,8]),]
out.com[order(out.com[,9]),]
out.com[order(out.com[,8]),]
out.com[order(out.com[,8]),]
out.com[order(out.com[,9]),]
out.com
out.com[order(out.com[,8]),]
#' Fitting bivariate MGL copula models
#'
#' @description MGL.reg is used to fit bivariate MGL copula regression models.
#' @param U two-dimenstional matrix with values in [0,1].
#' @param X design matrix
#' @param copula 'MGL', 'MGL180', "MGL-EV", "MGL-EV180", "MGB2", "Normal" , "Student-t"
#' @param initpar Initial values for the parameters to be optimized over.
#' @param ... 		additional arguments to be passed to f.
#' @md
#' @return A list containing the following components:
#' * minimum   the value of the estimated minimum of f.
#' * estimate	  the point at which the minimum value of f is obtained.
#' * gradient	the gradient at the estimated minimum of f.
#' * hessian	the hessian at the estimated minimum of f (if requested).
#' @export
#'
#'
#'
MGL.mle <- function(U, copula = c('MGL', 'MGL180', "MGL-EV",
"MGL-EV180",
"Gumbel",
"Normal", "MGB2", "t"
),
initpar, ...){
dnormcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
dtcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "t",
param = param[2]))  # t copula
dgumcop <- function(U, param)
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param){
as.numeric(dcMGLEV(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB2")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
} else if(copula == "MGB2"){
dcop <- dMGB2
arg.cop <- argMGB2
}
# loglike.copula <- function(U, initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000}
return(res)}
# }
resopt <- nlm(f = copLogL,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = T)
# resopt
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
}
#
# m.MGLMGA180 <- MGL.mle(U,
#                        copula  = "MGL180",
#                        initpar = c(0.5))
knitr::kable(out.com[order(out.com[,9]),], digits = 3)
out.com[order(out.com[,9]),]
out.com <- t(res.all)
out.com <- out.com[order(out.com[,9]),]
knitr::kable(out.com, digits = 3)
knitr::kable(out.com, digits = 2)
?order
out.com <- out.com[order(out.com[,9], decreasing = T)]
out.com
out.com <- out.com[order(out.com[,9], decreasing = T),]
out.com <- t(res.all)
out.com <- out.com[order(out.com[,9], decreasing = T),]
out.com
knitr::kable(out.com, digits = 2)
MGL.mle
MGL.mle
m.MGB2 <- MGL.mle(U,
copula  = "MGB2",
initpar = c(0.1, 2, 0.4))
m.MGLMGA180 <- MGL.mle(U,
copula  = "MGL180",
initpar = c(1))
m.MGB2 <- MGL.mle(U,
copula  = "MGB2",
initpar = c(0.1, 2, 0.4))
m.MGB2 <- MGL.mle(U,
copula  = "MGB2",
initpar = c(0.1, 2, 0.4))
m.MGLEV180 <- MGL.mle(U,
copula  = "MGL-EV180",
initpar = c(2))
m.MGLEV180 <- MGL.mle(U,
copula  = "MGL-EV180",
initpar = c(2))
m.norm <- MGL.mle(U = U,
copula  = "Normal",
initpar = 0.5)
devtools::document()
rm(list = c("MGL.mle"))
devtools::document()
library(rMGLReg)
? earthqCHI
？hcMGL.bivar
?hcMGL.bivar
usethis::use_vignette("counter-plot-MGLMGA")
>>>>>>> Stashed changes
library(rMGLReg)
dLMGA
library(rMGLReg)
dLMGA
?dLMGA
library(rMGLReg)
rMGLReg
??rMGLReg
?add
?dLMGA
library(rMGLReg)
dLMGA
usethis::use_package(package = "renv", type = "Suggests")
install.packages("usethis")
?dgamma
?add
library(rMGLReg)
devtools::document()
install.packages("devtools")
library(rMGLReg)
devtools::document()
devtools
install.packages("devtools")
install.packages("renv")
install.packages("renv")
install.packages("renv")
install.packages("renv")
install.packages("renv")
install.packages("renv")
install.packages("renv")
renv::restore()
renv::restore()
renv::restore()
renv::restore()‘’
renv::restore()‘’
renv::restore()
renv::restore()
library(rMGLReg)
add
?add
install.packages("roxygen2")
install.packages("Rcpp")
library(rMGLReg)
<<<<<<< Updated upstream
=======
?dLM
devtools::document()
?dLMGA
renv::init()
library(rMGLReg)
usethis::use_testthat()
use_test()
install.packages("testthat")
usethis::use_test()
test_that("multiplication works", {
expect_equal(2 * 2, 4)
})
renv::init()
install.packages("C:/Users/Administrator/Desktop/R-4.1.0.tar.gz", repos = NULL, type = "source")
renv::init()
renv::snapshot()
<<<<<<< Updated upstream
usethis::use_package(package = "renv", type = "Suggests")
install.packages("rmarkdown")
>>>>>>> Stashed changes
=======
earthqCHI
data(earthqCHI)
earthqCHI
?dcMGL.multi
library(rMGLReg)
?dcMGL.multi
?dgamma
?dcMGL.multi
?rcMGL180.multi
library(rMGLReg)
?dcMGL.multi
?dcMGL.multi
?dGLMGA
?pcMGLEV.bivar
styler::style_pkg()
?hcMGB2.bivar
?optim
?MGL.mle
library(rMGLReg)
?MGL.mle
?pcMGLEV.bivar
?rgamma
?cMGL.multi
?dcMGLEV180.bivar
?pcMGLEV.bivar
？dcMGL.bivar
?dcMGL.bivar
?dcMGL180.bivar
?rgamma
?dcMGL.bivar
library(rMGLReg)
renv::restore()
library(data.table)
library(rMGLReg)
dtnew <- fread('dtnew_copula.csv')
dtnew <- fread('/data-raw/dtnew_copula.csv')
dtnew <- fread('\data-raw\dtnew_copula.csv')
dtnew <- fread('\\data-raw\\dtnew_copula.csv')
getwd()
library(data.table)
library(rMGLReg)
dtnew <- fread('/data-raw/dtnew_copula.csv')
dtnew <- fread('D:/Rpackages/rMGLReg/data-raw/dtnew_copula.csv')
dtnew$ynew <- NULL
dtnew <- dtnew[year %in% seq(1990, 2015)]
dtadjust <- fread('dtcpi.csv', header = T)
dtadjust <- dtadjust[year %in% seq(1990, 2015)]
dtadjust
dtadjust[, CPI_factor := 1/(CPI/615.2)]
setkey(dtadjust, year)
dtnew <- fread('D:/Rpackages/rMGLReg/data-raw/dtnew_copula.csv')
dtnew$ynew <- NULL
dtnew <- dtnew[year %in% seq(1990, 2015)]
dtadjust <- fread('D:/Rpackages/rMGLReg/data-raw/dtcpi.csv', header = T)
dtadjust <- dtadjust[year %in% seq(1990, 2015)]
dtadjust
dtadjust[, CPI_factor := 1/(CPI/615.2)]
setkey(dtadjust, year)
setkey(dtnew, year)
dt <- merge(dtnew, dtadjust)
dt[is.na(y)]$y <- median(dt$y, na.rm = T)
dt[, ynew := y*CPI_factor]
dtnew <- dt[,.(year,
yraw = y,
#location = ,
y1 = ynew, magnitude, death, inj,intensity,
log.area, log.population,
y2 = death + inj)]
dtnew <- dt[,.(year,
yraw = y,
y1 = ynew, magnitude, death, inj,intensity,
y2 = death + inj)]
dtnew
Xsigma <- model.matrix(~ 1, data = dtnew);
# marginal distribution for y1
y <- dtnew$y1
Xsigma <- model.matrix(~ 1, data = dtnew);
Xb <- model.matrix(~ 1, data = dtnew)
LLlogmoyalGA3 <- function(y, pars, Xsigma, Xb) {
sigma <- exp(Xsigma %*% pars[1:dim(Xsigma)[2]])
b <- exp(Xb %*%pars[(dim(Xsigma)[2]+1):(dim(Xsigma)[2] + dim(Xb)[2])])
a <- exp(pars[dim(Xsigma)[2] + dim(Xb)[2]+1])
ll <- -0.5*log(2*pi) - log(sigma) + a*log(b) + lgamma(a + 0.5) - lgamma(a) - (1/(2*sigma)+1)*log(y) - (a + 0.5)*log(0.5*(1/y)^(1/sigma) + b)
loglike <- -sum(ll)
return(loglike)
}
mlogmoyalGA3 <- optim(fn = LLlogmoyalGA3, Xsigma = Xsigma,
Xb = Xb,
y = y, hessian = T,
control = list(maxit = 50000),
#method = 'Nelder-Mead',
#par = c(-1,-0.1,0.5,-2,-1))
par = c(-1,-1,-1))
# modout(mlogmoyalGA3)
#
pars <- mlogmoyalGA3$par
sigma <- exp(Xsigma %*% pars[1:dim(Xsigma)[2]])
b <- exp(Xb %*%pars[(dim(Xsigma)[2]+1):(dim(Xsigma)[2] + dim(Xb)[2])])
a <- exp(pars[dim(Xsigma)[2] + dim(Xb)[2]+1])
ufit <- c()
for(i in 1:length(y)){
ufit[i] <- pGLMGA(y[i], sigma = sigma[i], a = a, b = b[i])
}
pGLMGA
library(rMGLReg)
>>>>>>> Stashed changes
