#' * AIC, BIC: the goodness fit of the regression models.
#' * hessian: the hessian at the estimated maximum of the loglikelihood (if requested).
#' @details
#' * Y1: continuous data.
#' * Y2: semi-continuous data where Y2>umin is continuous and Y2<=umin is discrete.
#' * copula: "MGL180" and "MGLEV180" denote the survival MGL and survival MGL-EV copula respectively.
#' * For "Gumbel" regression model, the copula parameter \deqn{\delta_i = \exp(X\beta) + 1.}
#' * For "MGL", "MGL180", "MGL-EV", "MGL-EV180" regression model, the copula parameter \deqn{\delta_i = \exp(X\beta),} where \eqn{\beta} is the vector of coefficients to be estimated in the copula regression.
#'
#'
#'
#' @export
#'
#'
MGL.reg.mixed <- function(obs, U, U_, f, X, copula = c(
"MGL", "MGL180", "MGL-EV",
"MGL-EV180",
"Gumbel"
),
umin = 0,
hessian = TRUE, initpar, ...) {
dcMGL.reg <- function(U, param) {
dim <- length(U)
a <- 1 / param[1]
q <- qbeta(1 - U, shape1 = 0.5, shape2 = a) / (1 - qbeta(1 - U, shape1 = 0.5, shape2 = a))
logdc <- (dim - 1) * lgamma(a) + lgamma(a + dim / 2) - dim * lgamma(a + 0.5) + (a + 0.5) * sum(log(q + 1)) - (a + dim / 2) * log(sum(q) + 1)
out <- exp(logdc)
return(out)
}
dcMGL180.reg <- function(U, param) {
dcMGL.reg(1 - U, param = param)
}
dcMGLEV180.reg <- function(U, param) {
u1 <- U[1]
u2 <- U[2]
as.numeric(dcMGLEV180.bivar(u1, u2, param = param[1]))
}
dcMGLEV.reg <- function(U, param) {
u1 <- U[1]
u2 <- U[2]
as.numeric(dcMGLEV.bivar(u1, u2, param = param[1]))
}
dgumcop.reg <- function(U, param) {
as.numeric(fCopulae::devCopula(u = U[1], v = U[2], type = "gumbel", param = param[1])) # Bivariate Extreme
}
hcMGL.reg <- function(U, param) {
hfunc1 <- hcMGL.bivar(u1 = U[1], u2 = U[2], pars = param[1])$hfunc1
hfunc2 <- hcMGL.bivar(u1 = U[1], u2 = U[2], pars = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hcMGL180.reg <- function(U, param) {
hfunc1 <- 1 - hcMGL.bivar(u1 = 1 - U[1], u2 = 1 - U[2], pars = param[1])$hfunc1
hfunc2 <- 1 - hcMGL.bivar(u1 = 1 - U[1], u2 = 1 - U[2], pars = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hcMGLEV180.reg <- function(U, param) {
hfunc1 <- hcMGLEV180.bivar(u1 = U[1], u2 = U[2], param = param[1])$hfunc1
hfunc2 <- hcMGLEV180.bivar(u1 = U[1], u2 = U[2], param = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hcMGLEV.reg <- function(U, param) {
hfunc1 <- 1 - hcMGLEV180.bivar(u1 = 1 - U[1], u2 = 1 - U[2], param = param[1])$hfunc1
hfunc2 <- 1 - hcMGLEV180.bivar(u1 = 1 - U[1], u2 = 1 - U[2], param = param[1])$hfunc2
out <- list(hfunc1 = hfunc1, hfunc2 = hfunc2)
out
}
hgumcop.reg <- function(U, param) {
VineCopula::BiCopHfunc(u1 = U[1], u2 = U[2], family = 4, par = param[1])
}
if (copula == "MGL") {
dcop <- dcMGL.reg
hcop <- hcMGL.reg
} else if (copula == "MGL180") {
dcop <- dcMGL180.reg
hcop <- hcMGL180.reg
} else if (copula == "MGL-EV") {
dcop <- dcMGLEV.reg
hcop <- hcMGLEV.reg
} else if (copula == "MGL-EV180") {
dcop <- dcMGLEV180.reg
hcop <- hcMGLEV180.reg
} else if (copula == "Gumbel") {
dcop <- dgumcop.reg
hcop <- hgumcop.reg
}
# Obs1 <- obs[, 1] # y1 - the first vector of observations
Obs2 <- obs[, 2] # y2 - the second vector of observations
f1 <- f[, 1]
f2 <- f[, 2]
copLogL <- function(pars, X) {
ll <- 0
if (copula == "Gumbel") {
delta <- exp(X %*% pars) + 1
} else {
delta <- exp(X %*% pars)
}
for (i in seq_len(nrow(X))) {
if (Obs2[i] <= umin) {
ll[i] <- f1[i] * (hcop(U[i, ], param = delta[i])$hfunc1 - hcop(U_[i, ], param = delta[i])$hfunc1)
} else {
ll[i] <- f1[i] * f2[i] * dcop(U[i, ], param = delta[i])
}
}
res <- - sum((log(ll)))
return(res)
}
resopt <- optim(
par = initpar,
fn = copLogL,
X = X,
hessian = hessian, ...
)
resopt
list(
loglike = -resopt$value,
copula = list(name = copula),
estimates = resopt$par,
se = sqrt(diag(solve(resopt$hessian))),
hessian = -resopt$hessian,
AIC = 2 * length(resopt$par) + 2 * resopt$value,
BIC = log(nrow(U)) * length(resopt$par) + 2 * resopt$value
)
}
m.MGLMGA180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.MGLMGA180
m.MGLEV180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGLEV180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.MGLEV180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL-EV180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.gumbel <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "Gumbel",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.gumbel
library(rMGLReg)
u <- cbind(earthqCHI$u1, earthqCHI$u2)
u_ <- cbind(earthqCHI$u1, earthqCHI$u2_)
y <- cbind(earthqCHI$y1, earthqCHI$y2)
f <- cbind(earthqCHI$f1, earthqCHI$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
library(splines)
X <- ns(earthqCHI$year, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
m.MGL180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.MGLEV180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL-EV180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
m.gumbel <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "Gumbel",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1, 1))
estimates.copula <- rbind((m.MGL180$estimates), (m.MGLEV180$estimates), (m.gumbel$estimates))
sd.copula <- rbind((m.MGL180$se), (m.MGLEV180$se), (m.gumbel$se))
ll.copula <- rbind((m.MGL180)$loglike, (m.MGLEV180)$loglike, (m.gumbel)$loglike)
AIC.copula <- rbind((m.MGL180)$AIC, (m.MGLEV180)$AIC, (m.gumbel)$AIC)
BIC.copula <- rbind((m.MGL180)$BIC, (m.MGLEV180)$BIC, (m.gumbel)$BIC)
table1 <- cbind(estimates.copula, sd.copula, ll.copula, AIC.copula, BIC.copula)
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "se", "se","se",'loglike', 'AIC', 'BIC')
table1
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "se", "se","se",'loglike', 'AIC', 'BIC')
table1
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "estimates", "se", "se", "se","se",'loglike', 'AIC', 'BIC')
knitr::kable(t(table1), digits = 3)
m.MGL180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
initpar = c(-0.32, 1, 1))
X
dim(X)
estimates.copula <- rbind((m.MGL180$estimates), (m.MGLEV180$estimates), (m.gumbel$estimates))
sd.copula <- rbind((m.MGL180$se), (m.MGLEV180$se), (m.gumbel$se))
ll.copula <- rbind((m.MGL180)$loglike, (m.MGLEV180)$loglike, (m.gumbel)$loglike)
AIC.copula <- rbind((m.MGL180)$AIC, (m.MGLEV180)$AIC, (m.gumbel)$AIC)
BIC.copula <- rbind((m.MGL180)$BIC, (m.MGLEV180)$BIC, (m.gumbel)$BIC)
table1 <- cbind(estimates.copula, sd.copula, ll.copula, AIC.copula, BIC.copula)
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "estimates", "se", "se", "se","se",'loglike', 'AIC', 'BIC')
knitr::kable(t(table1), digits = 3)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1980, to = 1990)
Xcopula <-  splines::ns(agepred, knots = quantile(dtnew$year, c(0.5)), intercept = T)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(dtnew$year, c(0.333, 0.667)), intercept = T)
par.est
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(dtnew$year, c(0.333, 0.667)), intercept = T)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
??mvrnorm
mvrnorm
library(MASS)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 2), main = 'Survival MGL')
lines(delta.est, col = 'red', lwd = 2)
library(MASS)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 2), main = 'Survival MGL')
lines(delta.est, col = 'red', lwd = 2)
# Surivial MGL-EV regression
par.est <- m.MGLEV180$estimates
agepred <- seq(from = 1980, to = 1990)
Xcopula <-  ns(agepred, knots = quantile(dtnew$year, c(0.5)), intercept = T)
library(MASS)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 2), main = 'Survival MGL')
lines(delta.est, col = 'red', lwd = 2)
# Surivial MGL-EV regression
par.est <- m.MGLEV180$estimates
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGLEV180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 2), main = 'Survival MGL-EV')
lines(delta.est, col = 'red', lwd = 2)
# Gumbel regression
par.est <- m.gumbel$estimates
delta.est <- exp(Xcopula%*%par.est) + 1
cov.est <- -solve(m.gumbel$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,]) + 1
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 2), main = 'Gumbel')
lines(delta.est, col = 'red', lwd = 2)
library(MASS)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Survival MGL')
lines(delta.est, col = 'red', lwd = 2)
# Surivial MGL-EV regression
par.est <- m.MGLEV180$estimates
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGLEV180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Survival MGL-EV')
lines(delta.est, col = 'red', lwd = 2)
# Gumbel regression
par.est <- m.gumbel$estimates
delta.est <- exp(Xcopula%*%par.est) + 1
cov.est <- -solve(m.gumbel$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,]) + 1
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Gumbel')
lines(delta.est, col = 'red', lwd = 2)
?earthqCHI
library(rMGLReg)
library(fitdistrplus)
library(splines)
library(snpar)
data("danishmulti")
dt <- data.table::data.table(danishmulti)
dtnew <- dt[Building>0&Contents>0]
y1 <- dtnew$Building
y2 <- dtnew$Contents
y <- cbind(y1, y2)
# empirical cdf
u1 <- snpar::kde(y[,1], kernel = "gaus",
xgrid = y[,1],
h = 0.2)$Fhat
u2 <- snpar::kde(y[,2], kernel = "gaus",
xgrid = y[,2],
h = 0.2)$Fhat
U <- cbind(u1, u2) # bivariate pseudo copula data.
plot(U)
library(ggplot2)
library(latex2exp)
Usample <- U
XY <- y
newtheme <-   theme_bw() + theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
axis.ticks.length = unit(-0.1, "cm"),
plot.title = element_text(hjust = 0.5),
legend.direction = 'vertical',
legend.position = c(.95, .99),
legend.justification = c("right", "top"),
legend.box.just = "right",
legend.text = element_text(size = 10))
dtplot <- data.frame(U1 = Usample[,1], U2 = Usample[,2],
logY1 = log(XY[,1]), logY2 = log(XY[,2]))
p1 <- ggplot(data = dtplot, mapping = aes(y = logY1,
x = logY2)) +
newtheme +
geom_point() +
labs(title = "",
x = TeX("$log Y_1$"),
y = TeX("$log Y_2$")) +
scale_x_continuous(limits = c(-7.5, 5),
breaks = seq(-7.5, 5, by = 2.5)) +
scale_y_continuous(limits = c(-5, 5),
breaks = seq(-5, 5, by = 2.5))
p1
p2 <- ggplot(data = dtplot, mapping = aes(y = U2,
x = U1)) +
newtheme +
geom_point() +
labs(title = "",
x = TeX("$u_1$"),
y = TeX("$u_2$")) +
scale_x_continuous(limits = c(0, 1),
breaks = seq(0, 1, by = 0.2)) +
scale_y_continuous(limits = c(0, 1),
breaks = seq(0, 1, by = 0.2))
p2
library(patchwork)
p0 <- p1 + p2 + plot_layout(ncol = 2)
p0
p0
library(rMGLReg)
library(devtools)
check(cleanup = FALSE,manual = TRUE,path = getwd())
build_manual(path=getwd())
build_manual(path=getwd())
？build_manual
?build_manual
getwd()
build_manual(pkg = "rMGLReg", path=getwd())
??rMGLReg
library(rMGLReg)
rMGLReg
??rMGLReg
?Rd2pdf
Rd2pdf()
install.packages("pkgdown")
usethis::use_pkgdown()
use_pkgdown_github_pages()
use_pkgdown_github_pages()
pkgdown::build_site()
?rMGLReg
usethis::use_pkgdown()
usethis::use_pkgdown()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
?rMGLReg
??rMGLReg
usethis::use_code_of_conduct()
usethis::use_github_links()
usethis::use_github_links()
usethis::use_github_links()
usethis::use_github_links()
usethis::use_github_links()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
library(rMGLReg)
## basic example code
set.seed(271)
n <- 1000
delta <- 1.2
d <- 3
U <- rcMGL.multi(n = 1000, d = d, pars = delta)
cor(U, method = "kendall")
par(pty = "s")
pairs(U, gap = 0, cex = 0.5)
# simulated data
set.seed(111)
Nsim <- 1000
beta.true <- c(-0.6, 0.5, 0.2) # true regression coefficients
x1 <- rnorm(n, 0, 1)
x2 <- rnorm(n, 0, 1)
X <- model.matrix(~ x1 + x2) # design matrix
delta.sim <- as.vector(exp(X%*%beta.true)) # true copula parameters
Usim <- matrix(0, nrow = n, ncol = d)
for (i in 1:n){
Usim[i, ] <- rcMGL.multi(n = 1, d = d, pars = delta.sim[i])
}
m.MGLMGA <- fit.cop.IFM.reg(U = Usim,
dcop = dGM.reg,
method = "Nelder-Mead",
X = X,
control = list(maxit = 100000,
fnscale = -1),
initpar = beta.true)
m.MGLMGA <- MGL.reg(U = U, copula = "MGL",
X = X, method = "Nelder-Mead",
initpar = c(-0.32, 0.001, 0.001)
)
m.MGLMGA$estimates
# simulated data
set.seed(111)
Nsim <- 1000
n <- 1000 # sample size
beta.true <- c(-0.6, 0.5, 0.2) # true regression coefficients
x1 <- rnorm(n, 0, 1)
x2 <- rnorm(n, 0, 1)
X <- model.matrix(~ x1 + x2) # design matrix
delta.sim <- as.vector(exp(X%*%beta.true)) # true copula parameters
Usim <- matrix(0, nrow = n, ncol = d)
for (i in 1:n){
Usim[i, ] <- rcMGL.multi(n = 1, d = d, pars = delta.sim[i])
}
m.MGLMGA <- MGL.reg(U = U, copula = "MGL",
X = X, method = "Nelder-Mead",
initpar = c(-0.32, 0.001, 0.001)
)
m.MGLMGA$estimates
m.MGLMGA <- MGL.reg(U = Usim, copula = "MGL",
X = X, method = "Nelder-Mead",
initpar = c(-0.32, 0.001, 0.001)
)
m.MGLMGA <- MGL.reg(U = Usim, copula = "MGL",
X = X, method = "Nelder-Mead",
initpar = c(-0.32, 0.001, 0.001)
)
m.MGLMGA$estimates
m.MGLMGA
library(rMGLReg)
pkgdown::build_site()
usethis::use_pkgdown()
pkgdown::build_site()
？strrep
sethis::use_pkgdown()
usethis::use_pkgdown()
usethis::use_pkgdown()
usethis::use_pkgdown()
pkgdown::build_site()
