#' @param copula 'MGL', 'MGL180', "MGL-EV", "MGL-EV180", "MGB2", "Normal" , "Student-t"
#' @param initpar Initial values for the parameters to be optimized over.
#' @param ... 		additional arguments to be passed to f.
#' @md
#' @return A list containing the following components:
#' * minimum   the value of the estimated minimum of f.
#' * estimate	  the point at which the minimum value of f is obtained.
#' * gradient	the gradient at the estimated minimum of f.
#' * hessian	the hessian at the estimated minimum of f (if requested).
#' @export
#'
#'
#'
MGL.mle <- function(U, copula = c('MGL', 'MGL180', "MGL-EV",
"MGL-EV180",
"Gumbel",
"Normal", "MGB2", "t"
),
initpar, ...){
dnormcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
dtcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "t",
param = param[2]))  # t copula
dgumcop <- function(U, param)
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param){
as.numeric(dcMGLEV(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
} else if(copula == "MGB2"){
dcop <- dMGB2
arg.cop <- argMGB2
}
# loglike.copula <- function(U, initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000}
return(res)}
# }
resopt <- nlm(f = copLogL,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = F)
# resopt
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
}
#
# m.MGLMGA180 <- MGL.mle(U,
#                        copula  = "MGL180",
#                        initpar = c(0.5))
m.MGLMGA180 <- MGL.mle(U,
copula  = "MGL180",
initpar = c(1))
MGL.mle
#' Fitting bivariate MGL copula models
#'
#' @description MGL.reg is used to fit bivariate MGL copula regression models.
#' @param U two-dimenstional matrix with values in [0,1].
#' @param X design matrix
#' @param copula 'MGL', 'MGL180', "MGL-EV", "MGL-EV180", "MGB2", "Normal" , "Student-t"
#' @param initpar Initial values for the parameters to be optimized over.
#' @param ... 		additional arguments to be passed to f.
#' @md
#' @return A list containing the following components:
#' * minimum   the value of the estimated minimum of f.
#' * estimate	  the point at which the minimum value of f is obtained.
#' * gradient	the gradient at the estimated minimum of f.
#' * hessian	the hessian at the estimated minimum of f (if requested).
#' @export
#'
#'
#'
MGL.mle <- function(U, copula = c('MGL', 'MGL180', "MGL-EV",
"MGL-EV180",
"Gumbel",
"Normal", "MGB2", "t"
),
initpar, ...){
dnormcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
dtcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "t",
param = param[2]))  # t copula
dgumcop <- function(U, param)
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param){
as.numeric(dcMGLEV(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
} else if(copula == "MGB2"){
dcop <- dMGB2
arg.cop <- argMGB2
}
# loglike.copula <- function(U, initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000}
return(res)}
# }
resopt <- nlm(f = copLogL,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = T)
# resopt
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
}
#
# m.MGLMGA180 <- MGL.mle(U,
#                        copula  = "MGL180",
#                        initpar = c(0.5))
m.MGLMGA180 <- MGL.mle(U,
copula  = "MGL180",
initpar = c(1))
m.MGLMGA180
recap <- function(x){
res <- c(alpha = x$estimates,
se = x$se,
loglike = x$loglike,
AIC = x$AIC, BIC = x$BIC)
if(length(res) < 6)
res <- c(res[1], NA, NA,res[2], NA, NA, res[3:5])
if (length(res) > 6 & length(res) < 9)
res <- c(res[1:2], NA, res[3:4], NA, res[5:7])
res <- as.matrix(res)
colnames(res) <- x$copula$name
res}
res.all <- round(cbind(recap(m.norm),
recap(m.t),
recap(m.gumbel),
recap(m.MGLMGA180),
recap(m.MGB2),
recap(m.MGLEV180)
), 4)
out.com <- t(res.all)
out.com[order(out.com[,8]),]
out.com[order(out.com[,9]),]
out.com[order(out.com[,8]),]
out.com[order(out.com[,8]),]
out.com[order(out.com[,9]),]
out.com
out.com[order(out.com[,8]),]
#' Fitting bivariate MGL copula models
#'
#' @description MGL.reg is used to fit bivariate MGL copula regression models.
#' @param U two-dimenstional matrix with values in [0,1].
#' @param X design matrix
#' @param copula 'MGL', 'MGL180', "MGL-EV", "MGL-EV180", "MGB2", "Normal" , "Student-t"
#' @param initpar Initial values for the parameters to be optimized over.
#' @param ... 		additional arguments to be passed to f.
#' @md
#' @return A list containing the following components:
#' * minimum   the value of the estimated minimum of f.
#' * estimate	  the point at which the minimum value of f is obtained.
#' * gradient	the gradient at the estimated minimum of f.
#' * hessian	the hessian at the estimated minimum of f (if requested).
#' @export
#'
#'
#'
MGL.mle <- function(U, copula = c('MGL', 'MGL180', "MGL-EV",
"MGL-EV180",
"Gumbel",
"Normal", "MGB2", "t"
),
initpar, ...){
dnormcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm")) # normal copula
dtcop <- function(U, param)
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "t",
param = param[2]))  # t copula
dgumcop <- function(U, param)
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1])) # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = U[,1], u2 = U[,2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[,1], u2 = U[,2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param){
as.numeric(dcMGLEV(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param){
as.numeric(dcMGLEV180.bivar(u1 = U[,1], u2 = U[,2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0,0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(length = 3, lower = c(0,0,0), upper = c(50, 50, 50),
name = "MGB2")
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if(copula == 'MGL'){
dcop <- dMGL
arg.cop <- argMG
} else if(copula == 'MGL180'){
dcop = dMGL180
arg.cop <- argMG180
} else if(copula == "MGL-EV"){
dcop = dMGLEV
arg.cop <- argMGLEV
} else if(copula == "MGL-EV180"){
dcop  <- dMGLEV180
arg.cop <- argMGLEV180
} else if(copula == "Gumbel"){
dcop  <- dgumcop
arg.cop <- arggum
} else if(copula == "Normal"){
dcop  <- dnormcop
arg.cop <- argnorm
} else if(copula == "t"){
dcop <- dtcop
arg.cop <- argt
} else if(copula == "MGB2"){
dcop <- dMGB2
arg.cop <- argMGB2
}
# loglike.copula <- function(U, initpar, ...){
copLogL <- function(x) {
if(all(arg.cop$lower < x && arg.cop$upper > x)){
logL <- log(dcop(U, param = x))
#res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else { res <- 10000000000000}
return(res)}
# }
resopt <- nlm(f = copLogL,
# U = U,
p = initpar,
# dcop = dcop, arg.cop = arg.cop,
hessian = T)
# resopt
list(loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(resopt$hessian))),
AIC = 2*length(resopt$estimate) + 2*resopt$minimum,
BIC = log(nrow(U))*length(resopt$estimate) + 2*resopt$minimum)
}
#
# m.MGLMGA180 <- MGL.mle(U,
#                        copula  = "MGL180",
#                        initpar = c(0.5))
knitr::kable(out.com[order(out.com[,9]),], digits = 3)
out.com[order(out.com[,9]),]
out.com <- t(res.all)
out.com <- out.com[order(out.com[,9]),]
knitr::kable(out.com, digits = 3)
knitr::kable(out.com, digits = 2)
?order
out.com <- out.com[order(out.com[,9], decreasing = T)]
out.com
out.com <- out.com[order(out.com[,9], decreasing = T),]
out.com <- t(res.all)
out.com <- out.com[order(out.com[,9], decreasing = T),]
out.com
knitr::kable(out.com, digits = 2)
MGL.mle
MGL.mle
m.MGB2 <- MGL.mle(U,
copula  = "MGB2",
initpar = c(0.1, 2, 0.4))
m.MGLMGA180 <- MGL.mle(U,
copula  = "MGL180",
initpar = c(1))
m.MGB2 <- MGL.mle(U,
copula  = "MGB2",
initpar = c(0.1, 2, 0.4))
m.MGB2 <- MGL.mle(U,
copula  = "MGB2",
initpar = c(0.1, 2, 0.4))
m.MGLEV180 <- MGL.mle(U,
copula  = "MGL-EV180",
initpar = c(2))
m.MGLEV180 <- MGL.mle(U,
copula  = "MGL-EV180",
initpar = c(2))
m.norm <- MGL.mle(U = U,
copula  = "Normal",
initpar = 0.5)
devtools::document()
rm(list = c("MGL.mle"))
devtools::document()
library(rMGLReg)
? earthqCHI
？hcMGL.bivar
?hcMGL.bivar
usethis::use_vignette("counter-plot-MGLMGA")
library(rMGLReg)
devtools::load_all(".")
dMGLMGA
library(rMGLReg)
library(ggplot2)
library(latex2exp)
library(data.table)
# =======================================================================
# Case I:
# sigma <- c(0.5, 0.5)
# a <- 20
# b <- c(5, 5)
# =======================================================================
n.grid <- 500
sigma <- c(0.5, 0.5)
a <- 20
b <- c(5, 5)
xgrid <- ygrid <- seq(0.01, 20, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d[,1] <- grid[,1]
mtrx3d[,2] <- grid[,2]
for(i in 1:nrow(mtrx3d)){
mtrx3d[i,3] = dMGLMGA(y1 = grid[i,1], y2 = grid[i,2],
sigma = sigma,
a = a, b = b)
}
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
bins <- 10
sigma1 <- sigma[1]; sigma2 <- sigma[2]
b1 <- b[1]; b2 <- b[2]
Nsim <- 1000
u1sim <- runif(Nsim, min = 0, max = 1)
y1sim <- qLMGA(u1sim, sigma = sigma1, a = a, b = b1)
library(rMGLReg)
library(ggplot2)
library(latex2exp)
library(data.table)
# =======================================================================
# Case I:
# sigma <- c(0.5, 0.5)
# a <- 20
# b <- c(5, 5)
# =======================================================================
n.grid <- 500
sigma <- c(0.5, 0.5)
a <- 20
b <- c(5, 5)
xgrid <- ygrid <- seq(0.01, 20, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d[,1] <- grid[,1]
mtrx3d[,2] <- grid[,2]
for(i in 1:nrow(mtrx3d)){
mtrx3d[i,3] = dMGLMGA(y1 = grid[i,1], y2 = grid[i,2],
sigma = sigma,
a = a, b = b)
}
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
bins <- 10
sigma1 <- sigma[1]; sigma2 <- sigma[2]
b1 <- b[1]; b2 <- b[2]
Nsim <- 1000
u1sim <- runif(Nsim, min = 0, max = 1)
y1sim <- qGLMGA(u1sim, sigma = sigma1, a = a, b = b1)
anew <- a + 0.5; b2new <- b2*(1 + y1sim^(-1/sigma1)/(2*b1))
y2sim <- NA
for(i in 1:Nsim){
y2sim[i] <- rLMGA(1, sigma = sigma2, a = anew, b = b2new[i])
}
library(rMGLReg)
qGLMGA
library(rMGLReg)
library(ggplot2)
library(latex2exp)
library(data.table)
# =======================================================================
# Case I:
# sigma <- c(0.5, 0.5)
# a <- 20
# b <- c(5, 5)
# =======================================================================
n.grid <- 500
sigma <- c(0.5, 0.5)
a <- 20
b <- c(5, 5)
xgrid <- ygrid <- seq(0.01, 20, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d[,1] <- grid[,1]
mtrx3d[,2] <- grid[,2]
for(i in 1:nrow(mtrx3d)){
mtrx3d[i,3] = dMGLMGA(y1 = grid[i,1], y2 = grid[i,2],
sigma = sigma,
a = a, b = b)
}
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
bins <- 10
sigma1 <- sigma[1]; sigma2 <- sigma[2]
b1 <- b[1]; b2 <- b[2]
Nsim <- 1000
u1sim <- runif(Nsim, min = 0, max = 1)
y1sim <- qGLMGA(u1sim, sigma = sigma1, a = a, b = b1)
anew <- a + 0.5; b2new <- b2*(1 + y1sim^(-1/sigma1)/(2*b1))
y2sim <- NA
for(i in 1:Nsim){
y2sim[i] <- rGLMGA(1, sigma = sigma2, a = anew, b = b2new[i])
}
rGLMGA
qGLMGA
?qGLMGA
library(rMGLReg)
qGLMGA
