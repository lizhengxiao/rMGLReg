<<<<<<< Updated upstream
=======
for(i in 1:Nsim){
y2sim[i] <- rGLMGA(1, sigma = sigma2, a = anew, b = b2new[i])
>>>>>>> Stashed changes
}
pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
#' @rdname cMGL.multi
#' @export
#' @examples
#' pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
pcMGL180.multi <- function(u, pars){
dim <- ncol(u)
delta <- pars[1]
q <- (qbeta(u, shape1 = 0.5, shape2 = delta) / (1 - qbeta(u, shape1 = 0.5, shape2 = delta)))
z <- 0
for (i in 1:nrow(u)) {
# if(any(q[i,] %in% Inf)) {
#   z[i] <- 0
# } else {
temp <- as.vector(q[i, ])
fin <- function(theta) { # rely on theta
m <- pgamma(q = temp/theta, shape = 0.5, scale = 1)
k <- base::prod(m)
out <- theta^(-(delta+1))*exp(-1/delta)/gamma(delta)
out    }
# fin <- Vectorize(fin)
z[i] <- as.numeric(pracma::integral(
fun = fin,
xmin = 0,
xmax = Inf, method = "Clenshaw"
))
}
return(z)
}
pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
#' @rdname cMGL.multi
#' @export
#' @examples
#' pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
pcMGL180.multi <- function(u, pars){
dim <- ncol(u)
delta <- pars[1]
q <- (qbeta(u, shape1 = 0.5, shape2 = delta) / (1 - qbeta(u, shape1 = 0.5, shape2 = delta)))
z <- 0
for (i in 1:nrow(u)) {
# if(any(q[i,] %in% Inf)) {
#   z[i] <- 0
# } else {
temp <- as.vector(q[i, ])
fin <- function(theta) { # rely on theta
m <- pgamma(q = temp/theta, shape = 0.5, scale = 1)
k <- base::prod(m)
out <- theta^(-(delta+1))*exp(-1/theta)/gamma(delta)
out    }
fin <- Vectorize(fin)
z[i] <- as.numeric(pracma::integral(
fun = fin,
xmin = 0,
xmax = Inf, method = "Clenshaw"
))
}
return(z)
}
pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.5, 0.9)), pars = 3)
pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.5, 0.9)), pars = 0.5)
#' @rdname cMGL.multi
#' @export
#' @examples
#' pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
pcMGL180.multi <- function(u, pars){
dim <- ncol(u)
delta <- pars[1]
q <- (qbeta(u, shape1 = 0.5, shape2 = delta) / (1 - qbeta(u, shape1 = 0.5, shape2 = delta)))
z <- 0
for (i in 1:nrow(u)) {
# if(any(q[i,] %in% Inf)) {
#   z[i] <- 0
# } else {
temp <- as.vector(q[i, ])
fin <- function(theta) { # rely on theta
m <- pgamma(q = temp/theta, shape = 0.5, scale = 1)
k <- base::prod(m)
out <- theta^(-(delta+1))*exp(-1/theta)/gamma(delta)
out
}
# fin <- Vectorize(fin)
z[i] <- as.numeric(pracma::integral(
fun = fin,
xmin = 0,
xmax = Inf, method = "Clenshaw"
))
}
return(z)
}
pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.5, 0.9)), pars = 0.5)
?pcMGB2.bivar
pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.5, 0.9)), pars = 0.8)
pcMGB2.bivar(u = cbind(c(0.5, 0.5), c(0.5, 0.9)), pars1 = 0.5, pars2 = 0.5, pars3 = 0.8)
?pcMGB2.bivar
pcMGB2.bivar(u1 = c(0.5, 0.1), u2 = c(0.9, 0.1), pars1 = 0.5, pars2 = 0.5, pars3 = 1.5)
pcMGB2.bivar(u = cbind(c(0.5, 0.5), c(0.5, 0.9)), pars1 = 0.5, pars2 = 0.5, pars3 = 0.8)
c(0.5, 0.1)
c(0.9, 0.1)
# pcMGB2.bivar(u = cbind(c(0.5, 0.5), c(0.5, 0.9)), pars1 = 0.5, pars2 = 0.5, pars3 = 0.8)
pcMGB2.bivar(u1 = c(0.5, 0.1), u2 = c(0.9, 0.1), pars1 = 0.5, pars2 = 0.5, pars3 = 1.5)
cbind(c(0.5, 0.1), c(0.9, 0.1))
pcMGL180.multi(u = cbind(c(0.5, 0.1), c(0.9, 0.1)), pars = 0.8)
# pcMGB2.bivar(u = cbind(c(0.5, 0.5), c(0.5, 0.9)), pars1 = 0.5, pars2 = 0.5, pars3 = 0.8)
pcMGB2.bivar(u1 = c(0.5, 0.1), u2 = c(0.9, 0.1), pars1 = 0.5, pars2 = 0.5, pars3 = 1.5)
#' @rdname cMGL.multi
#' @export
#' @examples
#' pcMGL180.multi(u = cbind(c(0.5, 0.5), c(0.01, 0.9)), pars = 3)
pcMGL180.multi <- function(u, pars){
dim <- ncol(u)
delta <- pars[1]
q <- (qbeta(u, shape1 = 0.5, shape2 = delta) / (1 - qbeta(u, shape1 = 0.5, shape2 = delta)))
z <- 0
for (i in 1:nrow(u)) {
# if(any(q[i,] %in% Inf)) {
#   z[i] <- 0
# } else {
temp <- as.vector(q[i, ])
fin <- function(theta) { # rely on theta
m <- pgamma(q = temp/theta, shape = 0.5, scale = 1)
k <- base::prod(m)
out <- k*theta^(-(delta+1))*exp(-1/theta)/gamma(delta)
out
}
# fin <- Vectorize(fin)
z[i] <- as.numeric(pracma::integral(
fun = fin,
xmin = 0,
xmax = Inf, method = "Clenshaw"
))
}
return(z)
}
pcMGL180.multi(u = cbind(c(0.5, 0.1), c(0.9, 0.1)), pars = 0.8)
# pcMGB2.bivar(u = cbind(c(0.5, 0.5), c(0.5, 0.9)), pars1 = 0.5, pars2 = 0.5, pars3 = 0.8)
pcMGB2.bivar(u1 = c(0.5, 0.1), u2 = c(0.9, 0.1), pars1 = 0.5, pars2 = 0.5, pars3 = 1.5)
pcMGL180.multi(u = cbind(c(0.5, 0.1), c(0.9, 0.1)), pars = 1.5)
# pcMGB2.bivar(u = cbind(c(0.5, 0.5), c(0.5, 0.9)), pars1 = 0.5, pars2 = 0.5, pars3 = 0.8)
pcMGB2.bivar(u1 = c(0.5, 0.1), u2 = c(0.9, 0.1), pars1 = 0.5, pars2 = 0.5, pars3 = 1.5)
pcMGL180.multi(u = cbind(c(0.5, 0.5,0.12), c(0.01, 0.9,0.59)), pars = 3)
?pgamma
?cMGL.multi
?cMGL.multi
library(rMGLReg)
?cMGL.multi
?cMGL.multi
?BMGL
?hcMGL.bivar
?BSMGL
hcMGL180.bivar
?hcMGL180.bivar
library(rMGLReg)
? package or namespace load failed for 'rMGLReg' in namespaceExport(ns, exports):
?hcMGL180.bivar
?hcMGL.bivar
?dcMGL.bivar
?MGL.mle.mixed
?nlm
?cMGL.multi
?nlm
dcMGL180.bivar
dcMGB2.bivar
dcMGLEV.bivar
dcMGLEV180.bivar
hcMGL.bivar
library(rMGLReg)
?MGL.mle.mixed
?MGL.reg
library(rMGLReg)
MGL.reg
?MGL.reg
?MGL.mle.mixed
?MGL.mle.mixed
library(rMGLReg)
?dcMGL.bivar
?BMGL-EV
?pcMGLEV.bivar
?hMGLEV.bivar
library(rMGLReg)
library(rMGLReg)
?pcMGLEV.bivar
?dMGLMGA
?MGL.reg.mixed
library(rMGLReg)
?MGL.reg.mixed
?MGL.reg.mixed
?MGL.reg
library(rMGLReg)
library(rMGLReg)
?MGL.reg
install.packages("styler")
styler::style_pkg()
lintr::lint_package()
install.packages("lintr")
lintr::lint_package()
seq_len(u)
seq_len(c(1,2,3))
?seq_len
seq_len(5)
library(rMGLReg)
?MGL.reg
library(rMGLReg)
set.seed(271)
n <- 1000
delta <- 1.2
d <- 3
U <- rcMGL.multi(n = 1000, d = d, pars = delta)
cor(U, method = "kendall")
set.seed(271)
n <- 1000
delta <- 1.2
d <- 3
U <- rcMGL180.multi(n = 1000, d = d, pars = delta)
cor(U, method = "kendall")
par(pty = "s")
pairs(U, gap = 0, cex = 0.5)
library(rMGLReg)
set.seed(271)
n <- 1000
delta <- 1.2
d <- 3
U <- rcMGL.multi(n = 1000, d = d, pars = delta)
cor(U, method = "kendall")
library(data.table)
library(ggplot2)
library(latex2exp)
par.copula <- 0.5
usim <- (rcMGL.bivar(Nsim, pars = par.copula))
Nsim <- 1000
usim <- (rcMGL.bivar(Nsim, pars = par.copula))
library(data.table)
library(ggplot2)
library(latex2exp)
par.copula <- 0.5
Nsim <- 1000
usim <- (rcMGL.bivar(Nsim, pars = par.copula))
usim <- data.table(u1 = usim[,1], u2 = usim[,2])
n.grid <- 200
xgrid <- ygrid <- seq(0.01, 1, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d <- cbind(grid, "cu1u2" = dcGLMGA(u1 = grid[,1], u2 = grid[,2], pars = par.copula)) # evaluate W on 'grid'
rcMGL.bivar
mtrx3d <- cbind(grid, "cu1u2" = dcMGL.bivar(u1 = grid[,1], u2 = grid[,2], pars = par.copula)) # evaluate W on 'grid'
library(data.table)
library(ggplot2)
library(latex2exp)
par.copula <- 0.5
Nsim <- 1000
usim <- (rcMGL.bivar(Nsim, pars = par.copula))
usim <- data.table(u1 = usim[,1], u2 = usim[,2])
n.grid <- 200
xgrid <- ygrid <- seq(0.01, 1, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d <- cbind(grid, "cu1u2" = dcMGL.bivar(u1 = grid[,1], u2 = grid[,2], pars = par.copula)) # evaluate W on 'grid'
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
v1p <- ggplot() +
scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +
theme_bw() +
ggtitle(TeX(sprintf('MGL copula ($\\delta = %g$ )', par.copula))) +
theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
plot.title = element_text(hjust = 0.5)) +
labs(x = TeX("$u_1$"), y = TeX("$u_2$"))  +
geom_point(data = usim, aes(x = u1, y = u2),
size = 1,
color = 'red')
v1p
library(data.table)
library(ggplot2)
library(latex2exp)
par.copula <- 0.5
Nsim <- 1000
usim <- (rcMGL.bivar(Nsim, pars = par.copula))
usim <- data.table(u1 = usim[,1], u2 = usim[,2])
n.grid <- 200
xgrid <- ygrid <- seq(0.01, 1, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d <- cbind(grid, "cu1u2" = dcMGL.bivar(u1 = grid[,1], u2 = grid[,2], pars = par.copula)) # evaluate W on 'grid'
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
v1p <- ggplot() +
scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +
theme_bw() +
ggtitle(TeX(sprintf('MGL copula ($\\delta = %g$ )', par.copula))) +
theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
plot.title = element_text(hjust = 0.5)) +
labs(x = TeX("$u_1$"), y = TeX("$u_2$"))  +
geom_contour(data = mtrx3d,
aes(x = u1, y = u2, z = cu1u2),
bins = bins,
colour = 'black', weight = 3) +
geom_point(data = usim, aes(x = u1, y = u2),
size = 1,
color = 'red')
library(data.table)
library(ggplot2)
library(latex2exp)
par.copula <- 0.5
Nsim <- 1000
bins <- 30
usim <- (rcMGL.bivar(Nsim, pars = par.copula))
usim <- data.table(u1 = usim[,1], u2 = usim[,2])
n.grid <- 200
xgrid <- ygrid <- seq(0.01, 1, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d <- cbind(grid, "cu1u2" = dcMGL.bivar(u1 = grid[,1], u2 = grid[,2], pars = par.copula)) # evaluate W on 'grid'
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
v1p <- ggplot() +
scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +
theme_bw() +
ggtitle(TeX(sprintf('MGL copula ($\\delta = %g$ )', par.copula))) +
theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
plot.title = element_text(hjust = 0.5)) +
labs(x = TeX("$u_1$"), y = TeX("$u_2$"))  +
geom_contour(data = mtrx3d,
aes(x = u1, y = u2, z = cu1u2),
bins = bins,
colour = 'black', weight = 3) +
geom_point(data = usim, aes(x = u1, y = u2),
size = 1,
color = 'red')
v1p
library(data.table)
library(ggplot2)
library(latex2exp)
par.copula <- 0.51
Nsim <- 1000
bins <- 30
usim <- (rcMGL.bivar(Nsim, pars = par.copula))
usim <- data.table(u1 = usim[,1], u2 = usim[,2])
n.grid <- 200
xgrid <- ygrid <- seq(0.01, 1, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d <- cbind(grid, "cu1u2" = dcMGL.bivar(u1 = grid[,1], u2 = grid[,2], pars = par.copula)) # evaluate W on 'grid'
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
v1p <- ggplot() +
scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +
theme_bw() +
ggtitle(TeX(sprintf('MGL copula ($\\delta = %g$ )', par.copula))) +
theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
plot.title = element_text(hjust = 0.5)) +
labs(x = TeX("$u_1$"), y = TeX("$u_2$"))  +
geom_contour(data = mtrx3d,
aes(x = u1, y = u2, z = cu1u2),
bins = bins,
colour = 'black', weight = 3) +
geom_point(data = usim, aes(x = u1, y = u2),
size = 1,
color = 'red')
v1p
par.copula <- 3.81
Nsim <- 1000
bins <- 30
usim <- (rcMGL.bivar(Nsim, pars = par.copula))
usim <- data.table(u1 = usim[,1], u2 = usim[,2])
n.grid <- 200
xgrid <- ygrid <- seq(0.01, 1, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d <- cbind(grid, "cu1u2" = dcMGL.bivar(u1 = grid[,1], u2 = grid[,2], pars = par.copula)) # evaluate W on 'grid'
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
v1p <- ggplot() +
scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +
theme_bw() +
ggtitle(TeX(sprintf('MGL copula ($\\delta = %g$ )', par.copula))) +
theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
plot.title = element_text(hjust = 0.5)) +
labs(x = TeX("$u_1$"), y = TeX("$u_2$"))  +
geom_contour(data = mtrx3d,
aes(x = u1, y = u2, z = cu1u2),
bins = bins,
colour = 'black', weight = 3) +
geom_point(data = usim, aes(x = u1, y = u2),
size = 1,
color = 'red')
v1p
par.copula <- 10.56
Nsim <- 1000
usim <- (rcMGL.bivar(Nsim, pars = par.copula))
usim <- data.table(u1 = usim[,1], u2 = usim[,2])
n.grid <- 200
xgrid <- ygrid <- seq(0.01, 1, length.out = n.grid)
grid <- expand.grid("u1" = xgrid, "u2" = ygrid)
mtrx3d <- matrix(0, nrow = nrow(grid), ncol = 3)
mtrx3d <- cbind(grid, "cu1u2" = dcMGL.bivar(u1 = grid[,1], u2 = grid[,2], pars = par.copula)) # evaluate W on 'grid'
head(mtrx3d)
mtrx3d <- data.table(u1 = mtrx3d[,1], u2 = mtrx3d[,2], cu1u2 = mtrx3d[,3])
v3p <- ggplot() +
scale_x_continuous(expand = c(0, 0), limits = c(0, 1)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, 1)) +
theme_bw() +
ggtitle(TeX(sprintf('MGL copula ($\\delta = %g$ )', par.copula))) +
theme(axis.line = element_line(colour = "black"),
axis.text.x = element_text(margin = margin(t = 0.25, unit = "cm")),
axis.text.y = element_text(margin = margin(r = 0.25, unit = "cm"),
size = 10,
vjust = 0.5,
hjust = 0.5),
plot.title = element_text(hjust = 0.5)) +
labs(x = TeX("$u_1$"), y = TeX("$u_2$"))  +
geom_contour(data = mtrx3d,
aes(x = u1, y = u2, z = cu1u2),
bins = bins,
colour = 'black', weight = 3) +
geom_point(data = usim, aes(x = u1, y = u2),
size = 1,
color = 'red')
v3p
library(patchwork)
p1 <- v1p + v2p + v3p + plot_layout(ncol = 3)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(rMGLReg)
u <- cbind(earth_model$u1, earth_model$u2)
earthqCHI
library(rMGLReg)
u <- cbind(earthqCHI$u1, earthqCHI$u2)
u_ <- cbind(earthqCHI$u1, earthqCHI$u2_)
y <- cbind(earthqCHI$y1, earthqCHI$y2)
f <- cbind(earthqCHI$f1, earthqCHI$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
m.norm <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Normal", method = "L-BFGS-B",
initpar = 0.2)
m.t <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "t", method = "L-BFGS-B",
initpar = c(0.1,3))
m.gumbel <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "Gumbel",  method = "L-BFGS-B",
initpar = c(2))
m.MGLMGA180 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGL180",  method = "L-BFGS-B",
initpar = c(2))
m.MGB2 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGB2",  method = "L-BFGS-B",
initpar = c(1, 4, 0.4))
m.MGLEV180 <- MGL.mle.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f,
copula = "MGL-EV180",  method = "L-BFGS-B",
initpar = c(0.2))
recap <- function(x){
res <- c(alpha = x$estimates,
se = x$se,
loglike = x$loglike,
AIC = x$AIC, BIC = x$BIC)
if(length(res) < 6)
res <- c(res[1], NA, NA,res[2], NA, NA, res[3:5])
if (length(res) > 6 & length(res) < 9)
res <- c(res[1:2], NA, res[3:4], NA, res[5:7])
res <- as.matrix(res)
colnames(res) <- x$copula$name
res}
res.all <- round(cbind(recap(m.norm),
recap(m.t),
recap(m.gumbel),
recap(m.MGLMGA180),
recap(m.MGB2),
recap(m.MGLEV180)
), 4)
out.com <- t(res.all)
out.com <- out.com[order(out.com[,9], decreasing = T),]
knitr::kable(out.com, digits = 3)
round(out.com, 2)
round(out.com, 2)
hcMGL.bivar
<<<<<<< Updated upstream
round(out.com, 2)
round(out.com, 2)
knitr::kable(out.com, digits = 3)
=======
library(rMGLReg)
m.MGL180$se
library(rMGLReg)
u <- cbind(earthqCHI$u1, earthqCHI$u2)
u_ <- cbind(earthqCHI$u1, earthqCHI$u2_)
y <- cbind(earthqCHI$y1, earthqCHI$y2)
f <- cbind(earthqCHI$f1, earthqCHI$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
library(splines)
X <- ns(earthqCHI$year, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
m.MGL180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(0.64, 1.2, 1, -0.2))
m.MGLEV180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL-EV180",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(-0.32, 1, 1, 1))
m.gumbel <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "Gumbel",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(-0.32, 1, 1, 1))
m.MGL180
m.MGL180$se
sd.copula
estimates.copula <- rbind((m.MGL180$estimates), (m.MGLEV180$estimates), (m.gumbel$estimates))
sd.copula <- rbind((m.MGL180$se), (m.MGLEV180$se), (m.gumbel$se))
ll.copula <- rbind((m.MGL180)$loglike, (m.MGLEV180)$loglike, (m.gumbel)$loglike)
AIC.copula <- rbind((m.MGL180)$AIC, (m.MGLEV180)$AIC, (m.gumbel)$AIC)
BIC.copula <- rbind((m.MGL180)$BIC, (m.MGLEV180)$BIC, (m.gumbel)$BIC)
table1 <- cbind(estimates.copula, sd.copula, ll.copula, AIC.copula, BIC.copula)
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "estimates", "se", "se", "se","se",'loglike', 'AIC', 'BIC')
knitr::kable(t(table1), digits = 3)
library(rMGLReg)
u <- cbind(earthqCHI$u1, earthqCHI$u2)
u_ <- cbind(earthqCHI$u1, earthqCHI$u2_)
y <- cbind(earthqCHI$y1, earthqCHI$y2)
f <- cbind(earthqCHI$f1, earthqCHI$f2)
obs <- y
U <- u
U_ <- u_
umin <- 20
library(splines)
X <- ns(earthqCHI$year, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
m.MGL180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL180",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(0.64, 1.2, 1, -0.2))
m.MGLEV180 <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "MGL-EV180",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(-0.32, 1, 1, 1))
m.gumbel <- MGL.reg.mixed(obs = y, U = U, U_ = U_, umin = umin, f = f, X = X,
copula = "Gumbel",
method = "Nelder-Mead",
control = list(maxit = 100000),
initpar = c(-0.32, 1, 1, 1))
estimates.copula <- rbind((m.MGL180$estimates), (m.MGLEV180$estimates), (m.gumbel$estimates))
sd.copula <- rbind((m.MGL180$se), (m.MGLEV180$se), (m.gumbel$se))
ll.copula <- rbind((m.MGL180)$loglike, (m.MGLEV180)$loglike, (m.gumbel)$loglike)
AIC.copula <- rbind((m.MGL180)$AIC, (m.MGLEV180)$AIC, (m.gumbel)$AIC)
BIC.copula <- rbind((m.MGL180)$BIC, (m.MGLEV180)$BIC, (m.gumbel)$BIC)
table1 <- cbind(estimates.copula, sd.copula, ll.copula, AIC.copula, BIC.copula)
row.names(table1) <- c('MGL180', 'MGLEV180', 'Gumbel')
colnames(table1) <- c("estimates", "estimates","estimates", "estimates", "se", "se", "se","se",'loglike', 'AIC', 'BIC')
knitr::kable(t(table1), digits = 3)
library(MASS)
# Survival MGL regression model
par.est <- m.MGL180$estimates
agepred <- seq(from = 1990, to = 2015, by = 1)
Xcopula <-  ns(agepred, knots = quantile(earthqCHI$year, c(0.333, 0.667)), intercept = T)
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGL180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Survival MGL')
lines(delta.est, col = 'red', lwd = 2)
# Surivial MGL-EV regression
par.est <- m.MGLEV180$estimates
delta.est <- exp(Xcopula%*%par.est)
cov.est <- -solve(m.MGLEV180$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,])
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Survival MGL-EV')
lines(delta.est, col = 'red', lwd = 2)
# Gumbel regression
par.est <- m.gumbel$estimates
delta.est <- exp(Xcopula%*%par.est) + 1
cov.est <- -solve(m.gumbel$hessian)
beta.sim <- matrix(0, nrow = 100, ncol = 4)
delta.mat <- matrix(0, nrow = length(agepred), ncol = 100)
beta.sim <- mvrnorm(100, mu = par.est, Sigma = cov.est)
for(i in 1:100){
delta.mat[,i] <- exp(Xcopula%*%beta.sim[i,]) + 1
}
matplot(delta.mat, col = 'gray', type = 'l', ylim = c(0, 6), main = 'Gumbel')
lines(delta.est, col = 'red', lwd = 2)
FALSE
library(rMGLReg)
pkgdown::build_site()
pkgdown::build_site()
devtools::check()
devtools::check()
ï¼Ÿsrc
?src
usethis::use_pkgdown()
pkgdown::build_site()
usethis::use_tidy_github_actions()
devtools::build_rmd()
library(rMGLReg)
library(rMGLReg)
install.packages("rMGLReg")
library(rMGLReg)
>>>>>>> Stashed changes
