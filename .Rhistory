for (i in 1:nrow(mtrx3d)) {
mtrx3d[i, 3] <- dMGLMGA(
y1 = grid[i, 1], y2 = grid[i, 2],
sigma = sigma,
a = a, b = b
)
}
head(mtrx3d)
devtools::load_all(".")
?MGL.mle
?optim
?MGL.mle
?MGL.mle
?MGL.mle
rcMGL.bivar
library(rMGLReg)
Usim <- rcMGL.bivar(n = 1000, pars = 2.5)
m.MGL <- MGL.mle(U,
copula  = "MG",
initpar = c(2))
m.MGL
library(rMGLReg)
Usim <- rcMGL.bivar(n = 1000, pars = 2.5)
m.MGL <- MGL.mle(U,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
Usim <- rcMGL.bivar(n = 1000, pars = 0.5)
m.MGL <- MGL.mle(U,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
Usim <- rcMGL.bivar(n = 2000, pars = 0.5)
m.MGL <- MGL.mle(U,
copula  = "MGL",
initpar = c(2))
Usim <- rcMGL.bivar(n = 2000, pars = 0.5)
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
library(rMGLReg)
Usim <- rcMGL.bivar(n = 2000, pars = 0.5)
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
Usim <- rcMGL.bivar(n = 1000, pars = 0.5)
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
Usim <- rcMGL.bivar(n = 500, pars = 0.5)
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
rcMGL.multi
set.seed(112)
Usim <- rcMGL.multi(n = 500, d = 2, pars = 0.5)
plot(Usim)
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
Usim <- rcMGL.multi(n = 500, d = 2, pars = 2)
plot(Usim)
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
plot(Usim)
Usim <- rcMGL.multi(n = 1000, d = 2, pars = 2)
plot(Usim)
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
cor(Usim, method = "kendall")
set.seed(112)
Usim <- rcMGL.multi(n = 1000, d = 10, pars = 2)
cor(Usim, method = "kendall")
Usim <- rcMGL.multi(n = 500, d = 10, pars = 2)
cor(Usim, method = "kendall")
cor(Usim, method = "kendall")
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
knitr::kable(cor(Usim, method = "kendall"), digits = 2)
cor(Usim, method = "kendall")
round(cor(Usim, method = "kendall"), 2)
set.seed(111)
n <- 500
beta.true <- c(-0.6, 0.5, 0.2)
d <- 2
x1 <- rnorm(n, 0, 1)
x2 <- rnorm(n, 0, 1)
X <- model.matrix(~ x1 + x2)
delta.sim <- as.vector(exp(X%*%beta.true))
delta.sim
summary(delta.sim)
MGL.reg
?MGL.mle
?MGL.mle
for (i in 1:n){
Usim[i, ] <- rcGLMGA.multi(n = 1, d = d, param = delta.sim[i])
}
rcMGL.multi
Usim[i, ] <- rcMGL.multi(n = 1, d = d, pars = delta.sim[i])
for (i in 1:n){
Usim[i, ] <- rcMGL.multi(n = 1, d = d, pars = delta.sim[i])
}
Usim
m.MGL <- MGL.mle(U = Usim,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
m.MGL <- MGL.mle(U = Usim,
copula  = "MGL",
initpar = c(2, 1, 1))
# estimation results
m.MGL
m.MGL <- MGL.reg(U = Usim,
copula  = "MGL",
initpar = c(2, 1, 1))
?MGL.reg
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
initpar = c(2, 1, 1))
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
initpar = c(0.1, 1, 1))
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
initpar = c(0.1, 0.5, 1))
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
initpar = c(0.1, 0.5, 0.3))
# estimation results
m.MGL
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
initpar = c(-0.6, 0.5, 0.2))
# estimation results
m.MGL
set.seed(111)
n <- 200
beta.true <- c(-0.6, 0.5, 0.2)
d <- 2
x1 <- rnorm(n, 0, 1)
x2 <- rnorm(n, 0, 1)
X <- model.matrix(~ x1 + x2)
delta.sim <- as.vector(exp(X%*%beta.true))
summary(delta.sim)
for (i in 1:n){
Usim[i, ] <- rcMGL.multi(n = 1, d = d, pars = delta.sim[i])
}
Usim
dim(Usim)
d
Usim <- matrix(0, nrow = n, ncol = d)
for (i in 1:n){
Usim[i, ] <- rcMGL.multi(n = 1, d = d, pars = delta.sim[i])
}
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
hessian = TRUE,
initpar = c(-0.6, 0.5, 0.2))
# estimation results
m.MGL
# simulated the data
set.seed(111)
n <- 500
beta.true <- c(-0.6, 0.5, 0.2)
d <- 2
x1 <- rnorm(n, 0, 1)
x2 <- rnorm(n, 0, 1)
X <- model.matrix(~ x1 + x2)
delta.sim <- as.vector(exp(X%*%beta.true))
summary(delta.sim)
Usim <- matrix(0, nrow = n, ncol = d)
for (i in 1:n){
Usim[i, ] <- rcMGL.multi(n = 1, d = d, pars = delta.sim[i])
}
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
hessian = TRUE,
initpar = c(-0.6, 0.5, 0.2))
# estimation results
m.MGL
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
hessian = FALSE,
initpar = c(-0.6, 0.5, 0.2))
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
hessian = TRUE,
initpar = c(-0.6, 0.5, 0.2))
# estimation results
m.MGL
# simulated the data
set.seed(111)
n <- 500
beta.true <- c(-0.6, 0.5, 0.2)
d <- 10
x1 <- rnorm(n, 0, 1)
x2 <- rnorm(n, 0, 1)
X <- model.matrix(~ x1 + x2)
delta.sim <- as.vector(exp(X%*%beta.true))
summary(delta.sim)
Usim <- matrix(0, nrow = n, ncol = d)
for (i in 1:n){
Usim[i, ] <- rcMGL.multi(n = 1, d = d, pars = delta.sim[i])
}
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
hessian = TRUE,
initpar = c(-0.6, 0.5, 0.2))
# estimation results
m.MGL
summary(delta.sim)
library(rMGLReg)
# simulated the data
set.seed(111)
n <- 500
beta.true <- c(-0.6, 0.5, 0.2)
d <- 10
x1 <- rnorm(n, 0, 1)
x2 <- rnorm(n, 0, 1)
X <- model.matrix(~ x1 + x2)
delta.sim <- as.vector(exp(X%*%beta.true))
summary(delta.sim)
Usim <- matrix(0, nrow = n, ncol = d)
for (i in 1:n){
Usim[i, ] <- rcMGL.multi(n = 1, d = d, pars = delta.sim[i])
}
round(cor(Usim, method = "kendall"), 2)
m.MGL <- MGL.reg(U = Usim,
X = X,
copula  = "MGL",
hessian = TRUE,
initpar = c(-0.6, 0.5, 0.2))
# estimation results
m.MGL
#' @title Fitting bivariate MGL copula models
#' @description \code{MGL.mle} is used to fit bivariate copula regression models via maximum likelihood (ML) method for two continuous variables.
#' @param U two-dimenstional matrix with values in \eqn{[0,1]}.
#' @param copula copula 'MGL', 'MGL180', "MGL-EV", "MGL-EV180", "MGB2", "Normal" , "t".
#' @param hessian Logical. Should a numerically differentiated Hessian matrix be returned?
#' @param initpar Initial values for the parameters to be optimized over.
#' @param ... additional arguments, see \code{\link[stats]{nlm}} for more details.
#' @importFrom stats nlm
#' @md
#' @details
#' The estimation method is performed via \code{\link[stats]{nlm}} function.
#'
#' copula:
#' * "MGB2" is multivariate GB2.
#' * "Normal" and "t" denote the Gaussian copula and Student-t copula respectively.
#' * "MGL" and "MGL-EV" denote the MGL and MGL-EV copula respectively.
#' * "MGL180" and "MGL-EV180" denote the survival MGL and survival MGL-EV copula respectively.
#' * "Gumbel" is Gumbel copula.
#'
#' @return A list containing the following components:
#' * loglike: the value of the estimated maximum of the loglikelihood function.
#' * copula: the name of the fitted copula. "MGL180" and "MGL-EV180" denote the survival MGL and MGL-EV copula respectively.
#' * estimates: the point at which the maximum value of the loglikelihood is obtained.
#' * se: the standard errors of the estimators.
#' * AIC, BIC: the goodness fit of the regression models.
#' * hessian: the hessian at the estimated maximum of the loglikelihood (if requested).
#'
#' @references Zhang, F. Z. . "A generalized beta copula with applications in modeling multivariate long-tailed data." Insurance: Mathematics and Economics (2011).
#'
#' @examples
#'   library(rMGLReg)
#'   Usim <- rcMGL.bivar(n = 500, pars = 0.5)
#'   m.MGL <- MGL.mle(Usim,
#'   copula  = "MGL",
#'   initpar = c(2))
#'   # estimation results
#'   m.MGL
#' @export
#'
MGL.mle <- function(U, copula = c(
"MGL", "MGL180", "MGL-EV",
"MGL-EV180",
"Gumbel",
"Normal", "MGB2", "t"
),
hessian = TRUE,
initpar, ...) {
dnormcop <- function(U, param) {
as.numeric(fCopulae::dellipticalCopula(U, rho = param[1], type = "norm"))
} # normal copula
dtcop <- function(U, param) {
as.numeric(fCopulae::dellipticalCopula(U,
rho = param[1], type = "t",
param = param[2]
))
} # t copula
dgumcop <- function(U, param) {
as.numeric(fCopulae::devCopula(U, type = "gumbel", param = param[1]))
} # Bivariate Extreme
dMGL <- function(U, param) {
as.numeric(dcMGL.bivar(u1 = U[, 1], u2 = U[, 2], pars = param[1]))
}
dMGL180 <- function(U, param) {
as.numeric(dcMGL180.bivar(u1 = U[, 1], u2 = U[, 2], pars = param[1]))
}
dMGB2 <- function(U, param) {
as.numeric(dcMGB2.bivar(u1 = U[, 1], u2 = U[, 2], pars1 = param[1], pars2 = param[2], pars3 = param[3]))
}
dMGLEV <- function(U, param) {
as.numeric(dcMGLEV.bivar(u1 = U[, 1], u2 = U[, 2], param = param[1])) # Bivariate Extreme
}
dMGLEV180 <- function(U, param) {
as.numeric(dcMGLEV180.bivar(u1 = U[, 1], u2 = U[, 2], param = param[1])) # Bivariate Extreme
}
argnorm <- list(length = 1, lower = 0, upper = 1, name = "Gaussian")
argt <- list(length = 2, lower = c(0, 0), upper = c(1, 100), name = "Student")
arggum <- list(length = 1, lower = 1, upper = 50, name = "Gumbel")
argMGB2 <- list(
length = 3, lower = c(0, 0, 0), upper = c(50, 50, 50),
name = "MGB2"
)
argMG180 <- list(length = 1, lower = 0, upper = 10, name = "MGL180")
argMGLEV180 <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV180")
argMG <- list(length = 1, lower = 0, upper = 10, name = "MGL")
argMGLEV <- list(length = 1, lower = 0, upper = 10, name = "MGL-EV")
if (copula == "MGL") {
dcop <- dMGL
arg.cop <- argMG
} else if (copula == "MGL180") {
dcop <- dMGL180
arg.cop <- argMG180
} else if (copula == "MGL-EV") {
dcop <- dMGLEV
arg.cop <- argMGLEV
} else if (copula == "MGL-EV180") {
dcop <- dMGLEV180
arg.cop <- argMGLEV180
} else if (copula == "Gumbel") {
dcop <- dgumcop
arg.cop <- arggum
} else if (copula == "Normal") {
dcop <- dnormcop
arg.cop <- argnorm
} else if (copula == "t") {
dcop <- dtcop
arg.cop <- argt
} else if (copula == "MGB2") {
dcop <- dMGB2
arg.cop <- argMGB2
}
# loglike.copula <- function(U, initpar, ...){
copLogL <- function(x) {
if (all(arg.cop$lower < x && arg.cop$upper > x)) {
logL <- log(dcop(U, param = x))
# res <- -sum((logL))
remove.naninf <- function(x) x[!is.nan(x) & is.finite(x)]
res <- -sum(remove.naninf(logL))
} else {
res <- 10000000000000
}
return(res)
}
# }
resopt <- nlm(
f = copLogL,
p = initpar,
hessian = hessian, ...
)
# resopt
if (hessian == TRUE){
out <-   list(
loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
se = sqrt(diag(solve(resopt$hessian))),
hessian = -resopt$hessian,
AIC = 2 * length(resopt$estimate) + 2 * resopt$minimum,
BIC = log(nrow(U)) * length(resopt$estimate) + 2 * resopt$minimum
)
} else {
out <-   list(
loglike = -resopt$minimum,
copula = list(name = arg.cop$name),
estimates = resopt$estimate,
AIC = 2 * length(resopt$estimate) + 2 * resopt$minimum,
BIC = log(nrow(U)) * length(resopt$estimate) + 2 * resopt$minimum
)
}
out
}
library(rMGLReg)
set.seed(112)
Usim <- rcMGL.multi(n = 500, d = 10, pars = 2)
round(cor(Usim, method = "kendall"), 2)
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2))
# estimation results
m.MGL
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2),
hessian = TRUE)
m.MGL <- MGL.mle(Usim,
copula  = "MGL",
initpar = c(2),
hessian = FALSE)
m.MGL
Sys.setenv('PATH' = paste0('C:\\Program Files\\qpdf-version_number\\bin;', Sys.getenv('PATH')))
library(rMGLReg)
renv::status()
devtools::load_all(".")
？MGL.mle.mixed
?MGL.mle.mixed
devtools::load_all(".")
devtools::document()
?MGL.mle
usethis::use_version()
？MGL.mle.mixed
?MGL.mle.mixed
devtools::document()
devtools::document()
library(rMGLReg)
?MGL.mle.mixed
?cMGL.multi
?MGL.reg
devtools::document()
?MGL.reg
devtools::document()
?MGL.reg
devtools::document()
?MGL.reg
devtools::document()
?MGL.reg.multi
library(rMGLReg)
library(rMGLReg)
?earthqCHI
library(rMGLReg)
library(rMGLReg)
Afun
library(rMGLReg)
library(rMGLReg)
library(rMGLReg)
library(rMGLReg)
m.MGLMGA <- MGL.Reg(U = Usim, copula = "MGL",
X = X, method = "Nelder-Mead",
initpar = c(-0.32, 0.001, 0.001)
)
?MGL.Reg
m.MGLMGA <- MGL.reg(U = Usim, copula = "MGL",
X = X, method = "Nelder-Mead",
initpar = c(-0.32, 0.001, 0.001)
)
usethis::use_version()
library(rMGLReg)
install.packages("pkgdown")
usethis::use_pkgdown()
pkgdown::build_site()
usethis::use_tidy_github_actions()
devtools::build_rmd()
usethis::use_pkgdown()
pkgdown::build_site()
warnings()
warnings()
pkgdown::build_site()
usethis::use_pkgdown()
pkgdown::build_site()
.Last.error.trace
usethis::use_pkgdown()
pkgdown::build_site()
pkgdown::build_site()
warnings()
pkgdown::build_site()
warnings()
pkgdown::build_site()
renv::restore()
usethis::use_mit_license()
usethis::use_version()
devtools::check()
usethis::use_pkgdown()
pkgdown::build_site()
library(rMGLReg)
install.packages("metR")
usethis::use_pkgdown()
pkgdown::build_site()
pkgdown::build_site()
